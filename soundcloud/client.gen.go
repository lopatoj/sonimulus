// Package soundcloud provides primitives to interact with the openapi HTTP API.
//
// Code generated by github.com/oapi-codegen/oapi-codegen/v2 version v2.5.1 DO NOT EDIT.
package soundcloud

import (
	"bytes"
	"context"
	"encoding/json"
	"fmt"
	"io"
	"net/http"
	"net/url"
	"strings"
	"time"

	"github.com/oapi-codegen/runtime"
	openapi_types "github.com/oapi-codegen/runtime/types"
)

const (
	AuthHeaderScopes = "AuthHeader.Scopes"
	OAuth2_1Scopes   = "oAuth2_1.Scopes"
)

// Defines values for CreateUpdatePlaylistFormRequestPlaylistSetType.
const (
	CreateUpdatePlaylistFormRequestPlaylistSetTypeAlbum    CreateUpdatePlaylistFormRequestPlaylistSetType = "album"
	CreateUpdatePlaylistFormRequestPlaylistSetTypePlaylist CreateUpdatePlaylistFormRequestPlaylistSetType = "playlist"
)

// Defines values for CreateUpdatePlaylistFormRequestPlaylistSharing.
const (
	CreateUpdatePlaylistFormRequestPlaylistSharingPrivate CreateUpdatePlaylistFormRequestPlaylistSharing = "private"
	CreateUpdatePlaylistFormRequestPlaylistSharingPublic  CreateUpdatePlaylistFormRequestPlaylistSharing = "public"
)

// Defines values for CreateUpdatePlaylistRequestPlaylistSetType.
const (
	CreateUpdatePlaylistRequestPlaylistSetTypeAlbum    CreateUpdatePlaylistRequestPlaylistSetType = "album"
	CreateUpdatePlaylistRequestPlaylistSetTypePlaylist CreateUpdatePlaylistRequestPlaylistSetType = "playlist"
)

// Defines values for CreateUpdatePlaylistRequestPlaylistSharing.
const (
	CreateUpdatePlaylistRequestPlaylistSharingPrivate CreateUpdatePlaylistRequestPlaylistSharing = "private"
	CreateUpdatePlaylistRequestPlaylistSharingPublic  CreateUpdatePlaylistRequestPlaylistSharing = "public"
)

// Defines values for OAuthTokenGrantType.
const (
	AuthorizationCode OAuthTokenGrantType = "authorization_code"
	ClientCredentials OAuthTokenGrantType = "client_credentials"
	RefreshToken      OAuthTokenGrantType = "refresh_token"
)

// Defines values for TrackAccess.
const (
	TrackAccessBlocked  TrackAccess = "blocked"
	TrackAccessPlayable TrackAccess = "playable"
	TrackAccessPreview  TrackAccess = "preview"
)

// Defines values for TrackDataRequestTrackEmbeddableBy.
const (
	TrackDataRequestTrackEmbeddableByAll  TrackDataRequestTrackEmbeddableBy = "all"
	TrackDataRequestTrackEmbeddableByMe   TrackDataRequestTrackEmbeddableBy = "me"
	TrackDataRequestTrackEmbeddableByNone TrackDataRequestTrackEmbeddableBy = "none"
)

// Defines values for TrackDataRequestTrackLicense.
const (
	TrackDataRequestTrackLicenseAllRightsReserved TrackDataRequestTrackLicense = "all-rights-reserved"
	TrackDataRequestTrackLicenseCcBy              TrackDataRequestTrackLicense = "cc-by"
	TrackDataRequestTrackLicenseCcByNc            TrackDataRequestTrackLicense = "cc-by-nc"
	TrackDataRequestTrackLicenseCcByNcNd          TrackDataRequestTrackLicense = "cc-by-nc-nd"
	TrackDataRequestTrackLicenseCcByNcSa          TrackDataRequestTrackLicense = "cc-by-nc-sa"
	TrackDataRequestTrackLicenseCcByNd            TrackDataRequestTrackLicense = "cc-by-nd"
	TrackDataRequestTrackLicenseCcBySa            TrackDataRequestTrackLicense = "cc-by-sa"
	TrackDataRequestTrackLicenseNoRightsReserved  TrackDataRequestTrackLicense = "no-rights-reserved"
)

// Defines values for TrackDataRequestTrackSharing.
const (
	TrackDataRequestTrackSharingPrivate TrackDataRequestTrackSharing = "private"
	TrackDataRequestTrackSharingPublic  TrackDataRequestTrackSharing = "public"
)

// Defines values for TrackMetadataRequestTrackEmbeddableBy.
const (
	TrackMetadataRequestTrackEmbeddableByAll  TrackMetadataRequestTrackEmbeddableBy = "all"
	TrackMetadataRequestTrackEmbeddableByMe   TrackMetadataRequestTrackEmbeddableBy = "me"
	TrackMetadataRequestTrackEmbeddableByNone TrackMetadataRequestTrackEmbeddableBy = "none"
)

// Defines values for TrackMetadataRequestTrackLicense.
const (
	TrackMetadataRequestTrackLicenseAllRightsReserved TrackMetadataRequestTrackLicense = "all-rights-reserved"
	TrackMetadataRequestTrackLicenseCcBy              TrackMetadataRequestTrackLicense = "cc-by"
	TrackMetadataRequestTrackLicenseCcByNc            TrackMetadataRequestTrackLicense = "cc-by-nc"
	TrackMetadataRequestTrackLicenseCcByNcNd          TrackMetadataRequestTrackLicense = "cc-by-nc-nd"
	TrackMetadataRequestTrackLicenseCcByNcSa          TrackMetadataRequestTrackLicense = "cc-by-nc-sa"
	TrackMetadataRequestTrackLicenseCcByNd            TrackMetadataRequestTrackLicense = "cc-by-nd"
	TrackMetadataRequestTrackLicenseCcBySa            TrackMetadataRequestTrackLicense = "cc-by-sa"
	TrackMetadataRequestTrackLicenseNoRightsReserved  TrackMetadataRequestTrackLicense = "no-rights-reserved"
)

// Defines values for TrackMetadataRequestTrackSharing.
const (
	TrackMetadataRequestTrackSharingPrivate TrackMetadataRequestTrackSharing = "private"
	TrackMetadataRequestTrackSharingPublic  TrackMetadataRequestTrackSharing = "public"
)

// Defines values for ResponseType.
const (
	ResponseTypeCode ResponseType = "code"
)

// Defines values for GetConnectParamsResponseType.
const (
	GetConnectParamsResponseTypeCode GetConnectParamsResponseType = "code"
)

// Defines values for GetMeActivitiesParamsAccess.
const (
	GetMeActivitiesParamsAccessBlocked  GetMeActivitiesParamsAccess = "blocked"
	GetMeActivitiesParamsAccessPlayable GetMeActivitiesParamsAccess = "playable"
	GetMeActivitiesParamsAccessPreview  GetMeActivitiesParamsAccess = "preview"
)

// Defines values for GetMeActivitiesAllOwnParamsAccess.
const (
	GetMeActivitiesAllOwnParamsAccessBlocked  GetMeActivitiesAllOwnParamsAccess = "blocked"
	GetMeActivitiesAllOwnParamsAccessPlayable GetMeActivitiesAllOwnParamsAccess = "playable"
	GetMeActivitiesAllOwnParamsAccessPreview  GetMeActivitiesAllOwnParamsAccess = "preview"
)

// Defines values for GetMeActivitiesTracksParamsAccess.
const (
	GetMeActivitiesTracksParamsAccessBlocked  GetMeActivitiesTracksParamsAccess = "blocked"
	GetMeActivitiesTracksParamsAccessPlayable GetMeActivitiesTracksParamsAccess = "playable"
	GetMeActivitiesTracksParamsAccessPreview  GetMeActivitiesTracksParamsAccess = "preview"
)

// Defines values for GetMeFollowingsTracksParamsAccess.
const (
	GetMeFollowingsTracksParamsAccessBlocked  GetMeFollowingsTracksParamsAccess = "blocked"
	GetMeFollowingsTracksParamsAccessPlayable GetMeFollowingsTracksParamsAccess = "playable"
	GetMeFollowingsTracksParamsAccessPreview  GetMeFollowingsTracksParamsAccess = "preview"
)

// Defines values for GetMeLikesTracksParamsAccess.
const (
	GetMeLikesTracksParamsAccessBlocked  GetMeLikesTracksParamsAccess = "blocked"
	GetMeLikesTracksParamsAccessPlayable GetMeLikesTracksParamsAccess = "playable"
	GetMeLikesTracksParamsAccessPreview  GetMeLikesTracksParamsAccess = "preview"
)

// Defines values for GetPlaylistsParamsAccess.
const (
	GetPlaylistsParamsAccessBlocked  GetPlaylistsParamsAccess = "blocked"
	GetPlaylistsParamsAccessPlayable GetPlaylistsParamsAccess = "playable"
	GetPlaylistsParamsAccessPreview  GetPlaylistsParamsAccess = "preview"
)

// Defines values for PostPlaylistsMultipartBodyPlaylistSetType.
const (
	PostPlaylistsMultipartBodyPlaylistSetTypeAlbum    PostPlaylistsMultipartBodyPlaylistSetType = "album"
	PostPlaylistsMultipartBodyPlaylistSetTypePlaylist PostPlaylistsMultipartBodyPlaylistSetType = "playlist"
)

// Defines values for PostPlaylistsMultipartBodyPlaylistSharing.
const (
	PostPlaylistsMultipartBodyPlaylistSharingPrivate PostPlaylistsMultipartBodyPlaylistSharing = "private"
	PostPlaylistsMultipartBodyPlaylistSharingPublic  PostPlaylistsMultipartBodyPlaylistSharing = "public"
)

// Defines values for GetPlaylistsPlaylistUrnParamsAccess.
const (
	GetPlaylistsPlaylistUrnParamsAccessBlocked  GetPlaylistsPlaylistUrnParamsAccess = "blocked"
	GetPlaylistsPlaylistUrnParamsAccessPlayable GetPlaylistsPlaylistUrnParamsAccess = "playable"
	GetPlaylistsPlaylistUrnParamsAccessPreview  GetPlaylistsPlaylistUrnParamsAccess = "preview"
)

// Defines values for GetPlaylistsPlaylistUrnTracksParamsAccess.
const (
	GetPlaylistsPlaylistUrnTracksParamsAccessBlocked  GetPlaylistsPlaylistUrnTracksParamsAccess = "blocked"
	GetPlaylistsPlaylistUrnTracksParamsAccessPlayable GetPlaylistsPlaylistUrnTracksParamsAccess = "playable"
	GetPlaylistsPlaylistUrnTracksParamsAccessPreview  GetPlaylistsPlaylistUrnTracksParamsAccess = "preview"
)

// Defines values for GetTracksParamsAccess.
const (
	GetTracksParamsAccessBlocked  GetTracksParamsAccess = "blocked"
	GetTracksParamsAccessPlayable GetTracksParamsAccess = "playable"
	GetTracksParamsAccessPreview  GetTracksParamsAccess = "preview"
)

// Defines values for PostTracksMultipartBodyTrackEmbeddableBy.
const (
	PostTracksMultipartBodyTrackEmbeddableByAll  PostTracksMultipartBodyTrackEmbeddableBy = "all"
	PostTracksMultipartBodyTrackEmbeddableByMe   PostTracksMultipartBodyTrackEmbeddableBy = "me"
	PostTracksMultipartBodyTrackEmbeddableByNone PostTracksMultipartBodyTrackEmbeddableBy = "none"
)

// Defines values for PostTracksMultipartBodyTrackLicense.
const (
	AllRightsReserved PostTracksMultipartBodyTrackLicense = "all-rights-reserved"
	CcBy              PostTracksMultipartBodyTrackLicense = "cc-by"
	CcByNc            PostTracksMultipartBodyTrackLicense = "cc-by-nc"
	CcByNcNd          PostTracksMultipartBodyTrackLicense = "cc-by-nc-nd"
	CcByNcSa          PostTracksMultipartBodyTrackLicense = "cc-by-nc-sa"
	CcByNd            PostTracksMultipartBodyTrackLicense = "cc-by-nd"
	CcBySa            PostTracksMultipartBodyTrackLicense = "cc-by-sa"
	NoRightsReserved  PostTracksMultipartBodyTrackLicense = "no-rights-reserved"
)

// Defines values for PostTracksMultipartBodyTrackSharing.
const (
	PostTracksMultipartBodyTrackSharingPrivate PostTracksMultipartBodyTrackSharing = "private"
	PostTracksMultipartBodyTrackSharingPublic  PostTracksMultipartBodyTrackSharing = "public"
)

// Defines values for GetTracksTrackUrnRelatedParamsAccess.
const (
	GetTracksTrackUrnRelatedParamsAccessBlocked  GetTracksTrackUrnRelatedParamsAccess = "blocked"
	GetTracksTrackUrnRelatedParamsAccessPlayable GetTracksTrackUrnRelatedParamsAccess = "playable"
	GetTracksTrackUrnRelatedParamsAccessPreview  GetTracksTrackUrnRelatedParamsAccess = "preview"
)

// Defines values for GetUsersUserUrnLikesTracksParamsAccess.
const (
	GetUsersUserUrnLikesTracksParamsAccessBlocked  GetUsersUserUrnLikesTracksParamsAccess = "blocked"
	GetUsersUserUrnLikesTracksParamsAccessPlayable GetUsersUserUrnLikesTracksParamsAccess = "playable"
	GetUsersUserUrnLikesTracksParamsAccessPreview  GetUsersUserUrnLikesTracksParamsAccess = "preview"
)

// Defines values for GetUsersUserUrnPlaylistsParamsAccess.
const (
	GetUsersUserUrnPlaylistsParamsAccessBlocked  GetUsersUserUrnPlaylistsParamsAccess = "blocked"
	GetUsersUserUrnPlaylistsParamsAccessPlayable GetUsersUserUrnPlaylistsParamsAccess = "playable"
	GetUsersUserUrnPlaylistsParamsAccessPreview  GetUsersUserUrnPlaylistsParamsAccess = "preview"
)

// Defines values for GetUsersUserUrnTracksParamsAccess.
const (
	GetUsersUserUrnTracksParamsAccessBlocked  GetUsersUserUrnTracksParamsAccess = "blocked"
	GetUsersUserUrnTracksParamsAccessPlayable GetUsersUserUrnTracksParamsAccess = "playable"
	GetUsersUserUrnTracksParamsAccessPreview  GetUsersUserUrnTracksParamsAccess = "preview"
)

// Activities User's activities.
type Activities struct {
	Collection *[]struct {
		// CreatedAt Created timestamp.
		CreatedAt *string `json:"created_at,omitempty"`

		// Origin Origin.
		Origin *Activities_Collection_Origin `json:"origin,omitempty"`

		// Type Type of activity (track).
		Type *string `json:"type,omitempty"`
	} `json:"collection,omitempty"`
	FutureHref *string `json:"future_href,omitempty"`
	NextHref   *string `json:"next_href,omitempty"`
}

// Activities_Collection_Origin Origin.
type Activities_Collection_Origin struct {
	union json.RawMessage
}

// Comment User's Comment
type Comment struct {
	// Body Comment body.
	Body *string `json:"body,omitempty"`

	// CreatedAt Created timestamp.
	CreatedAt *string `json:"created_at,omitempty"`

	// Kind Kind (comment).
	Kind *string `json:"kind,omitempty"`

	// Timestamp Timestamp.
	Timestamp *string `json:"timestamp,omitempty"`

	// TrackUrn Track's identifier.
	TrackUrn *string `json:"track_urn,omitempty"`

	// Uri Comment's URL.
	Uri *string `json:"uri,omitempty"`

	// Urn Identifier.
	Urn *string `json:"urn,omitempty"`

	// User SoundCloud User object
	User *struct {
		// AvatarUrl URL to a JPEG image.
		AvatarUrl *string `json:"avatar_url,omitempty"`

		// FollowersCount number of followers.
		FollowersCount *int `json:"followers_count,omitempty"`

		// FollowingsCount number of followed users.
		FollowingsCount *int `json:"followings_count,omitempty"`

		// Kind kind of resource.
		Kind *string `json:"kind,omitempty"`

		// LastModified last modified timestamp.
		LastModified *string `json:"last_modified,omitempty"`

		// Permalink permalink of the resource.
		Permalink *string `json:"permalink,omitempty"`

		// PermalinkUrl URL to the SoundCloud.com page.
		PermalinkUrl *string `json:"permalink_url,omitempty"`

		// RepostsCount number of reposts from user
		RepostsCount *int `json:"reposts_count,omitempty"`

		// Uri API resource URL.
		Uri *string `json:"uri,omitempty"`

		// Urn unique identifier
		Urn *string `json:"urn,omitempty"`

		// Username username
		Username *string `json:"username,omitempty"`
	} `json:"user,omitempty"`

	// UserUrn User's identifier.
	UserUrn *string `json:"user_urn,omitempty"`
}

// Comments defines model for Comments.
type Comments struct {
	Collection *[]Comment `json:"collection,omitempty"`
	NextHref   *string    `json:"next_href"`
}

// CreateUpdatePlaylistFormRequest defines model for CreateUpdatePlaylistFormRequest.
type CreateUpdatePlaylistFormRequest struct {
	PlaylistArtworkData   *openapi_types.File                             `json:"playlist[artwork_data],omitempty"`
	PlaylistDescription   *string                                         `json:"playlist[description],omitempty"`
	PlaylistEan           *string                                         `json:"playlist[ean],omitempty"`
	PlaylistGenre         *string                                         `json:"playlist[genre],omitempty"`
	PlaylistLabelName     *string                                         `json:"playlist[label_name],omitempty"`
	PlaylistLicense       *string                                         `json:"playlist[license],omitempty"`
	PlaylistPermalink     *string                                         `json:"playlist[permalink],omitempty"`
	PlaylistPermalinkUrl  *string                                         `json:"playlist[permalink_url],omitempty"`
	PlaylistPurchaseTitle *string                                         `json:"playlist[purchase_title],omitempty"`
	PlaylistPurchaseUrl   *string                                         `json:"playlist[purchase_url],omitempty"`
	PlaylistRelease       *string                                         `json:"playlist[release],omitempty"`
	PlaylistReleaseDate   *string                                         `json:"playlist[release_date],omitempty"`
	PlaylistSetType       *CreateUpdatePlaylistFormRequestPlaylistSetType `json:"playlist[set_type],omitempty"`
	PlaylistSharing       *CreateUpdatePlaylistFormRequestPlaylistSharing `json:"playlist[sharing],omitempty"`
	PlaylistTagList       *string                                         `json:"playlist[tag_list],omitempty"`
	PlaylistTitle         *string                                         `json:"playlist[title],omitempty"`

	// PlaylistTracksUrn To pass multiple tracks, pass multiple comma-separated values, e.g. -F "playlist[tracks][][urn]=soundcloud:tracks:111,soundcloud:tracks:222"
	PlaylistTracksUrn *string `json:"playlist[tracks][][urn],omitempty"`
}

// CreateUpdatePlaylistFormRequestPlaylistSetType defines model for CreateUpdatePlaylistFormRequest.PlaylistSetType.
type CreateUpdatePlaylistFormRequestPlaylistSetType string

// CreateUpdatePlaylistFormRequestPlaylistSharing defines model for CreateUpdatePlaylistFormRequest.PlaylistSharing.
type CreateUpdatePlaylistFormRequestPlaylistSharing string

// CreateUpdatePlaylistRequest defines model for CreateUpdatePlaylistRequest.
type CreateUpdatePlaylistRequest struct {
	Playlist *struct {
		ArtworkData *openapi_types.File `json:"artwork_data,omitempty"`

		// Description Description of the playlist
		Description *string `json:"description,omitempty"`

		// Ean The European Article Number
		Ean *string `json:"ean,omitempty"`

		// Genre Playlist's genre
		Genre *string `json:"genre,omitempty"`

		// LabelName Label name
		LabelName *string `json:"label_name,omitempty"`

		// License License number
		License *string `json:"license,omitempty"`

		// Permalink Playlist's permalink
		Permalink *string `json:"permalink,omitempty"`

		// PermalinkUrl Full permalink URL
		PermalinkUrl *string `json:"permalink_url,omitempty"`

		// PurchaseTitle Purchase title
		PurchaseTitle *string `json:"purchase_title,omitempty"`

		// PurchaseUrl Purchase URL
		PurchaseUrl *string `json:"purchase_url,omitempty"`

		// Release Playlist's release
		Release *string `json:"release,omitempty"`

		// ReleaseDate Release date
		ReleaseDate *string `json:"release_date,omitempty"`

		// SetType Playlist or album type
		SetType *CreateUpdatePlaylistRequestPlaylistSetType `json:"set_type,omitempty"`

		// Sharing public or private
		Sharing *CreateUpdatePlaylistRequestPlaylistSharing `json:"sharing,omitempty"`

		// TagList A comma-separated list of tags
		TagList *string `json:"tag_list,omitempty"`

		// Title Title of the playlist
		Title *string `json:"title,omitempty"`

		// Tracks List of tracks to add to playlist
		Tracks *[]struct {
			// Urn SoundCloud track urn
			Urn string `json:"urn"`
		} `json:"tracks,omitempty"`
	} `json:"playlist,omitempty"`
}

// CreateUpdatePlaylistRequestPlaylistSetType Playlist or album type
type CreateUpdatePlaylistRequestPlaylistSetType string

// CreateUpdatePlaylistRequestPlaylistSharing public or private
type CreateUpdatePlaylistRequestPlaylistSharing string

// Error defines model for Error.
type Error struct {
	Code *int `json:"code,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Error *string `json:"error"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Errors  *[]string `json:"errors,omitempty"`
	Link    *string   `json:"link,omitempty"`
	Message *string   `json:"message,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Status *string `json:"status,omitempty"`
}

// Found defines model for Found.
type Found struct {
	// Location Location URL of the resource.
	Location *string `json:"location,omitempty"`

	// Status Status code.
	Status *string `json:"status,omitempty"`
}

// Me SoundCloud Me object
type Me struct {
	// AvatarUrl URL to a JPEG image.
	AvatarUrl *string `json:"avatar_url,omitempty"`

	// City city.
	City *string `json:"city,omitempty"`

	// CommentsCount comments count. From now on, the field always has a `0` value.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	CommentsCount *int `json:"comments_count,omitempty"`

	// Country country.
	Country *string `json:"country,omitempty"`

	// CreatedAt created at date
	CreatedAt *string `json:"created_at,omitempty"`

	// Description description.
	Description *string `json:"description,omitempty"`

	// DiscogsName discogs name.
	DiscogsName *string `json:"discogs_name,omitempty"`

	// FirstName first name.
	FirstName *string `json:"first_name,omitempty"`

	// FollowersCount number of followers.
	FollowersCount *int `json:"followers_count,omitempty"`

	// FollowingsCount number of followed users.
	FollowingsCount *int `json:"followings_count,omitempty"`

	// FullName first and last name.
	FullName *string `json:"full_name,omitempty"`

	// Kind kind of resource.
	Kind *string `json:"kind,omitempty"`

	// LastModified last modified timestamp.
	LastModified *string `json:"last_modified,omitempty"`

	// LastName last name.
	LastName *string `json:"last_name,omitempty"`

	// LikesCount likes count.
	LikesCount *int `json:"likes_count,omitempty"`

	// Locale locale.
	Locale *string `json:"locale"`

	// Online online.
	Online *bool `json:"online,omitempty"`

	// Permalink permalink of the resource.
	Permalink *string `json:"permalink,omitempty"`

	// PermalinkUrl URL to the SoundCloud.com page.
	PermalinkUrl *string `json:"permalink_url,omitempty"`

	// Plan subscription plan of the user.
	Plan *string `json:"plan,omitempty"`

	// PlaylistCount number of public playlists.
	PlaylistCount *int `json:"playlist_count,omitempty"`

	// PrimaryEmailConfirmed boolean if email is confirmed.
	PrimaryEmailConfirmed *bool `json:"primary_email_confirmed,omitempty"`

	// PrivatePlaylistsCount number of private playlists.
	PrivatePlaylistsCount *int `json:"private_playlists_count,omitempty"`

	// PrivateTracksCount number of private tracks.
	PrivateTracksCount *int `json:"private_tracks_count,omitempty"`

	// PublicFavoritesCount number of favorited public tracks
	PublicFavoritesCount *int `json:"public_favorites_count,omitempty"`

	// Quota user's upload quota
	Quota *struct {
		// UnlimitedUploadQuota unlimited upload quota.
		UnlimitedUploadQuota *bool `json:"unlimited_upload_quota,omitempty"`

		// UploadSecondsLeft upload seconds left.
		UploadSecondsLeft *int `json:"upload_seconds_left"`

		// UploadSecondsUsed upload seconds used.
		UploadSecondsUsed *int `json:"upload_seconds_used,omitempty"`
	} `json:"quota,omitempty"`

	// RepostsCount number of reposts from user
	RepostsCount *int `json:"reposts_count,omitempty"`

	// Subscriptions a list subscriptions associated with the user
	Subscriptions interface{} `json:"subscriptions,omitempty"`

	// TrackCount number of public tracks.
	TrackCount *int `json:"track_count,omitempty"`

	// UploadSecondsLeft upload seconds left.
	UploadSecondsLeft *int `json:"upload_seconds_left"`

	// Uri API resource URL.
	Uri *string `json:"uri,omitempty"`

	// Urn unique identifier
	Urn *string `json:"urn,omitempty"`

	// Username username
	Username *string `json:"username,omitempty"`

	// Website a URL to the website.
	Website *string `json:"website,omitempty"`

	// WebsiteTitle a custom title for the website.
	WebsiteTitle *string `json:"website_title,omitempty"`
}

// OAuthToken defines model for OAuthToken.
type OAuthToken struct {
	// ClientId Client ID
	ClientId string `json:"client_id"`

	// ClientSecret Client secret
	ClientSecret string `json:"client_secret"`

	// Code Authorization code. Required on `grant_type = authorization_code`.
	Code *string `json:"code,omitempty"`

	// GrantType One of `authorization_code`, `client_credentials`, `refresh_token`
	GrantType OAuthTokenGrantType `json:"grant_type"`

	// RedirectUri Redirect URI. Required on `grant_type = (authorization_code|refresh_token)`.
	RedirectUri *string `json:"redirect_uri,omitempty"`

	// RefreshToken Refresh token. Required on `grant_type = refresh_token`.
	RefreshToken *string `json:"refresh_token,omitempty"`
}

// OAuthTokenGrantType One of `authorization_code`, `client_credentials`, `refresh_token`
type OAuthTokenGrantType string

// Playlist Soundcloud Playlist Object
type Playlist struct {
	// ArtworkUrl URL to a JPEG image.
	ArtworkUrl *string `json:"artwork_url,omitempty"`

	// CreatedAt Created timestamp.
	CreatedAt *string `json:"created_at,omitempty"`

	// Description Playlist description.
	Description *string `json:"description,omitempty"`

	// Downloadable is downloadable.
	Downloadable *bool `json:"downloadable,omitempty"`

	// Duration Playlist duration.
	Duration *int `json:"duration,omitempty"`

	// Ean European Article Number.
	Ean *string `json:"ean,omitempty"`

	// EmbeddableBy Embeddable by.
	EmbeddableBy *string `json:"embeddable_by,omitempty"`

	// Genre Playlist genre.
	Genre *string `json:"genre,omitempty"`

	// Kind Type of Soundcloud object (playlist).
	Kind  *string `json:"kind,omitempty"`
	Label *struct {
		// AvatarUrl URL to a JPEG image
		AvatarUrl *string `json:"avatar_url,omitempty"`

		// City city
		City *string `json:"city,omitempty"`

		// Country country
		Country *string `json:"country,omitempty"`

		// CreatedAt profile creation datetime
		CreatedAt *time.Time `json:"created_at,omitempty"`

		// Description description
		Description *string `json:"description,omitempty"`

		// DiscogsName discogs name
		DiscogsName *string `json:"discogs_name,omitempty"`

		// FirstName first name
		FirstName *string `json:"first_name,omitempty"`

		// FollowersCount number of followers
		FollowersCount *int `json:"followers_count,omitempty"`

		// FollowingsCount number of followed users
		FollowingsCount *int `json:"followings_count,omitempty"`

		// FullName first and last name
		FullName *string `json:"full_name,omitempty"`

		// Kind kind of resource
		Kind *string `json:"kind,omitempty"`

		// LastModified last modified datetime
		LastModified *time.Time `json:"last_modified,omitempty"`

		// LastName last name
		LastName *string `json:"last_name,omitempty"`

		// Permalink permalink of the resource
		Permalink *string `json:"permalink,omitempty"`

		// PermalinkUrl URL to the SoundCloud.com page
		PermalinkUrl *string `json:"permalink_url,omitempty"`

		// Plan subscription plan of the user
		Plan *string `json:"plan,omitempty"`

		// PlaylistCount number of public playlists
		PlaylistCount *int `json:"playlist_count,omitempty"`

		// PublicFavoritesCount number of favorited public tracks
		PublicFavoritesCount *int `json:"public_favorites_count,omitempty"`

		// RepostsCount number of reposts from user
		RepostsCount *int `json:"reposts_count,omitempty"`

		// Subscriptions a list subscriptions associated with the user
		// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
		Subscriptions interface{} `json:"subscriptions,omitempty"`

		// TrackCount number of public tracks
		TrackCount *int `json:"track_count,omitempty"`

		// Uri API resource URL
		Uri *string `json:"uri,omitempty"`

		// Urn unique identifier
		Urn *string `json:"urn,omitempty"`

		// Username username
		Username *string `json:"username,omitempty"`

		// Website a URL to the website
		Website *string `json:"website,omitempty"`

		// WebsiteTitle a custom title for the website
		WebsiteTitle *string `json:"website_title,omitempty"`
	} `json:"label,omitempty"`

	// LabelId Label user identifier.
	LabelId *int `json:"label_id,omitempty"`

	// LabelName Label name.
	LabelName *string `json:"label_name,omitempty"`

	// LastModified Last modified timestamp.
	LastModified *string `json:"last_modified,omitempty"`

	// License License.
	License *string `json:"license,omitempty"`

	// LikesCount Count of playlist likes.
	LikesCount *int `json:"likes_count,omitempty"`

	// Permalink Playlist permalink.
	Permalink *string `json:"permalink,omitempty"`

	// PermalinkUrl Playlist permalink URL.
	PermalinkUrl *string `json:"permalink_url,omitempty"`

	// PlaylistType Type of playlist.
	PlaylistType *string `json:"playlist_type,omitempty"`

	// PurchaseTitle Purchase title.
	PurchaseTitle *string `json:"purchase_title,omitempty"`

	// PurchaseUrl Purchase URL.
	PurchaseUrl *string `json:"purchase_url,omitempty"`

	// Release Release.
	Release *string `json:"release,omitempty"`

	// ReleaseDay Day of release.
	ReleaseDay *int `json:"release_day,omitempty"`

	// ReleaseMonth Month of release.
	ReleaseMonth *int `json:"release_month,omitempty"`

	// ReleaseYear Year of release.
	ReleaseYear *int `json:"release_year,omitempty"`

	// Sharing Type of sharing (private/public).
	Sharing *string `json:"sharing,omitempty"`

	// Streamable Is streamable.
	Streamable *bool `json:"streamable,omitempty"`

	// TagList Tags.
	TagList *string `json:"tag_list,omitempty"`

	// Tags Tags.
	Tags *string `json:"tags"`

	// Title Playlist title.
	Title *string `json:"title,omitempty"`

	// TrackCount Count of tracks.
	TrackCount *int `json:"track_count,omitempty"`

	// Tracks List of tracks.
	Tracks *[]Track `json:"tracks,omitempty"`

	// TracksUri tracks URI.
	TracksUri *string `json:"tracks_uri"`

	// Type Playlist type.
	Type *string `json:"type,omitempty"`

	// Uri Playlist URI.
	Uri *string `json:"uri,omitempty"`

	// Urn Playlist identifier.
	Urn *string `json:"urn,omitempty"`

	// User SoundCloud User object
	User *User `json:"user"`

	// UserUrn User identifier.
	UserUrn *string `json:"user_urn,omitempty"`
}

// Playlists defines model for Playlists.
type Playlists struct {
	Collection *[]Playlist `json:"collection,omitempty"`
	NextHref   *string     `json:"next_href,omitempty"`
}

// PlaylistsArray defines model for PlaylistsArray.
type PlaylistsArray = []Playlist

// Streams defines model for Streams.
type Streams struct {
	HlsAac160Url *string `json:"hls_aac_160_url,omitempty"`
	HlsMp3128Url *string `json:"hls_mp3_128_url,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	HlsOpus64Url *string `json:"hls_opus_64_url,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	HttpMp3128Url    *string `json:"http_mp3_128_url,omitempty"`
	PreviewMp3128Url *string `json:"preview_mp3_128_url,omitempty"`
}

// TooManyRequests defines model for TooManyRequests.
type TooManyRequests struct {
	Code *int `json:"code,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Error *string `json:"error"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Errors         *[]string `json:"errors,omitempty"`
	Link           *string   `json:"link,omitempty"`
	Message        *string   `json:"message,omitempty"`
	SpamWarningUrn *string   `json:"spam_warning_urn,omitempty"`
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Status *string `json:"status,omitempty"`
}

// Track Soundcloud Track object.
type Track struct {
	// Access Level of access the user (logged in or anonymous) has to the track.
	//   * `playable` - user is allowed to listen to a full track.
	//   * `preview` - user is allowed to preview a track, meaning a snippet is available
	//   * `blocked` - user can only see the metadata of a track, no streaming is possible
	Access *TrackAccess `json:"access"`

	// ArtworkUrl URL to a JPEG image.
	ArtworkUrl *string `json:"artwork_url,omitempty"`

	// AvailableCountryCodes List of countries where track is available.
	AvailableCountryCodes *string `json:"available_country_codes,omitempty"`

	// Bpm Tempo.
	Bpm *int `json:"bpm,omitempty"`

	// CommentCount Number of comments.
	CommentCount *int `json:"comment_count,omitempty"`

	// Commentable Is commentable.
	Commentable *bool `json:"commentable,omitempty"`

	// CreatedAt Created timestamp.
	CreatedAt *string `json:"created_at,omitempty"`

	// Description Track description.
	Description *string `json:"description,omitempty"`

	// DownloadCount NUmber of downloads.
	DownloadCount *int `json:"download_count,omitempty"`

	// DownloadUrl URL to download a track.
	DownloadUrl *string `json:"download_url,omitempty"`

	// Downloadable Is downloadable.
	Downloadable *string `json:"downloadable,omitempty"`

	// Duration Track duration.
	Duration *int `json:"duration,omitempty"`

	// EmbeddableBy Embeddable by.
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	EmbeddableBy *string `json:"embeddable_by,omitempty"`

	// FavoritingsCount Number of favoritings.
	FavoritingsCount *int `json:"favoritings_count,omitempty"`

	// Genre Genre
	Genre *string `json:"genre,omitempty"`

	// Isrc ISRC code.
	Isrc *string `json:"isrc,omitempty"`

	// KeySignature Key signature.
	KeySignature *string `json:"key_signature,omitempty"`

	// Kind Type of object (track).
	Kind *string `json:"kind,omitempty"`

	// LabelName Label user name.
	LabelName *string `json:"label_name,omitempty"`

	// License License
	License *string `json:"license,omitempty"`

	// MetadataArtist Optional artist name, when different from user.
	MetadataArtist *string `json:"metadata_artist,omitempty"`

	// PermalinkUrl Permalink URL.
	PermalinkUrl *string `json:"permalink_url,omitempty"`

	// PlaybackCount Number of plays.
	PlaybackCount *int `json:"playback_count,omitempty"`

	// PurchaseTitle Purchase title.
	PurchaseTitle *string `json:"purchase_title,omitempty"`

	// PurchaseUrl Purchase URL.
	PurchaseUrl *string `json:"purchase_url,omitempty"`

	// Release Release.
	Release *string `json:"release,omitempty"`

	// ReleaseDay Day of release.
	ReleaseDay *int `json:"release_day,omitempty"`

	// ReleaseMonth Month of release.
	ReleaseMonth *int `json:"release_month,omitempty"`

	// ReleaseYear Year of release.
	ReleaseYear *int `json:"release_year,omitempty"`

	// RepostsCount Number of reposts.
	RepostsCount *int `json:"reposts_count,omitempty"`

	// SecretUri Secret URL.
	SecretUri *string `json:"secret_uri,omitempty"`

	// Sharing Type of sharing (public/private).
	Sharing *string `json:"sharing,omitempty"`

	// StreamUrl URL to stream.
	StreamUrl *string `json:"stream_url,omitempty"`

	// Streamable Is streamable.
	Streamable *bool `json:"streamable,omitempty"`

	// TagList Tags.
	TagList *string `json:"tag_list,omitempty"`

	// Title Track title.
	Title *string `json:"title,omitempty"`

	// Uri Track URI.
	Uri *string `json:"uri,omitempty"`

	// Urn Track identifier.
	Urn *string `json:"urn,omitempty"`

	// User SoundCloud User object
	User *User `json:"user"`

	// UserFavorite Is user's favourite. It is only set when fetching search results or single track, otherwise it is false.
	UserFavorite *bool `json:"user_favorite,omitempty"`

	// UserPlaybackCount Number of plays by a user.
	UserPlaybackCount *int `json:"user_playback_count,omitempty"`

	// WaveformUrl Waveform URL.
	WaveformUrl *string `json:"waveform_url,omitempty"`
}

// TrackAccess Level of access the user (logged in or anonymous) has to the track.
//   - `playable` - user is allowed to listen to a full track.
//   - `preview` - user is allowed to preview a track, meaning a snippet is available
//   - `blocked` - user can only see the metadata of a track, no streaming is possible
type TrackAccess string

// TrackDataRequest defines model for TrackDataRequest.
type TrackDataRequest struct {
	TrackArtworkData  *openapi_types.File `json:"track[artwork_data],omitempty"`
	TrackAssetData    *openapi_types.File `json:"track[asset_data],omitempty"`
	TrackCommentable  *bool               `json:"track[commentable],omitempty"`
	TrackDescription  *string             `json:"track[description],omitempty"`
	TrackDownloadable *bool               `json:"track[downloadable],omitempty"`

	// TrackEmbeddableBy who can embed this track "all", "me", or "none"
	TrackEmbeddableBy *TrackDataRequestTrackEmbeddableBy `json:"track[embeddable_by],omitempty"`
	TrackGenre        *string                            `json:"track[genre],omitempty"`
	TrackIsrc         *string                            `json:"track[isrc],omitempty"`
	TrackLabelName    *string                            `json:"track[label_name],omitempty"`

	// TrackLicense Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
	TrackLicense     *TrackDataRequestTrackLicense `json:"track[license],omitempty"`
	TrackPermalink   *string                       `json:"track[permalink],omitempty"`
	TrackPurchaseUrl *string                       `json:"track[purchase_url],omitempty"`
	TrackRelease     *string                       `json:"track[release],omitempty"`

	// TrackReleaseDate string, formatted as yyyy-mm-dd, representing release date
	TrackReleaseDate *string                       `json:"track[release_date],omitempty"`
	TrackSharing     *TrackDataRequestTrackSharing `json:"track[sharing],omitempty"`
	TrackStreamable  *bool                         `json:"track[streamable],omitempty"`

	// TrackTagList The tag_list property contains a list of tags separated by spaces. Multiword tags are quoted in double quotes. We also support machine tags that follow the pattern NAMESPACE:KEY=VALUE. For example: geo:lat=43.555 camel:size=medium “machine:tag=with space” Machine tags are not revealed to the user on the track pages.
	TrackTagList *string `json:"track[tag_list],omitempty"`
	TrackTitle   *string `json:"track[title],omitempty"`
}

// TrackDataRequestTrackEmbeddableBy who can embed this track "all", "me", or "none"
type TrackDataRequestTrackEmbeddableBy string

// TrackDataRequestTrackLicense Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
type TrackDataRequestTrackLicense string

// TrackDataRequestTrackSharing defines model for TrackDataRequest.TrackSharing.
type TrackDataRequestTrackSharing string

// TrackMetadataRequest defines model for TrackMetadataRequest.
type TrackMetadataRequest struct {
	Track *struct {
		Commentable  *bool   `json:"commentable,omitempty"`
		Description  *string `json:"description,omitempty"`
		Downloadable *bool   `json:"downloadable,omitempty"`

		// EmbeddableBy who can embed this track "all", "me", or "none"
		EmbeddableBy *TrackMetadataRequestTrackEmbeddableBy `json:"embeddable_by,omitempty"`
		Genre        *string                                `json:"genre,omitempty"`
		Isrc         *string                                `json:"isrc,omitempty"`
		LabelName    *string                                `json:"label_name,omitempty"`

		// License Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
		License     *TrackMetadataRequestTrackLicense `json:"license,omitempty"`
		Permalink   *string                           `json:"permalink,omitempty"`
		PurchaseUrl *string                           `json:"purchase_url,omitempty"`
		Release     *string                           `json:"release,omitempty"`

		// ReleaseDate string, formatted as yyyy-mm-dd, representing release date
		ReleaseDate *string                           `json:"release_date,omitempty"`
		Sharing     *TrackMetadataRequestTrackSharing `json:"sharing,omitempty"`
		Streamable  *bool                             `json:"streamable,omitempty"`

		// TagList The tag_list property contains a list of tags separated by spaces. Multiword tags are quoted in double quotes. We also support machine tags that follow the pattern NAMESPACE:KEY=VALUE. For example: geo:lat=43.555 camel:size=medium “machine:tag=with space” Machine tags are not revealed to the user on the track pages.
		TagList *string `json:"tag_list,omitempty"`
		Title   *string `json:"title,omitempty"`
	} `json:"track,omitempty"`
}

// TrackMetadataRequestTrackEmbeddableBy who can embed this track "all", "me", or "none"
type TrackMetadataRequestTrackEmbeddableBy string

// TrackMetadataRequestTrackLicense Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
type TrackMetadataRequestTrackLicense string

// TrackMetadataRequestTrackSharing defines model for TrackMetadataRequest.Track.Sharing.
type TrackMetadataRequestTrackSharing string

// Tracks defines model for Tracks.
type Tracks struct {
	Collection *[]Track `json:"collection,omitempty"`
	NextHref   *string  `json:"next_href,omitempty"`
}

// TracksList defines model for TracksList.
type TracksList = []Track

// User SoundCloud User object
type User struct {
	// AvatarUrl URL to a JPEG image
	AvatarUrl *string `json:"avatar_url,omitempty"`

	// City city
	City *string `json:"city,omitempty"`

	// Country country
	Country *string `json:"country,omitempty"`

	// CreatedAt profile creation datetime
	CreatedAt *time.Time `json:"created_at,omitempty"`

	// Description description
	Description *string `json:"description,omitempty"`

	// DiscogsName discogs name
	DiscogsName *string `json:"discogs_name,omitempty"`

	// FirstName first name
	FirstName *string `json:"first_name,omitempty"`

	// FollowersCount number of followers
	FollowersCount *int `json:"followers_count,omitempty"`

	// FollowingsCount number of followed users
	FollowingsCount *int `json:"followings_count,omitempty"`

	// FullName first and last name
	FullName *string `json:"full_name,omitempty"`

	// Kind kind of resource
	Kind *string `json:"kind,omitempty"`

	// LastModified last modified datetime
	LastModified *time.Time `json:"last_modified,omitempty"`

	// LastName last name
	LastName *string `json:"last_name,omitempty"`

	// Permalink permalink of the resource
	Permalink *string `json:"permalink,omitempty"`

	// PermalinkUrl URL to the SoundCloud.com page
	PermalinkUrl *string `json:"permalink_url,omitempty"`

	// Plan subscription plan of the user
	Plan *string `json:"plan,omitempty"`

	// PlaylistCount number of public playlists
	PlaylistCount *int `json:"playlist_count,omitempty"`

	// PublicFavoritesCount number of favorited public tracks
	PublicFavoritesCount *int `json:"public_favorites_count,omitempty"`

	// RepostsCount number of reposts from user
	RepostsCount *int `json:"reposts_count,omitempty"`

	// Subscriptions a list subscriptions associated with the user
	// Deprecated: this property has been marked as deprecated upstream, but no `x-deprecated-reason` was set
	Subscriptions interface{} `json:"subscriptions,omitempty"`

	// TrackCount number of public tracks
	TrackCount *int `json:"track_count,omitempty"`

	// Uri API resource URL
	Uri *string `json:"uri,omitempty"`

	// Urn unique identifier
	Urn *string `json:"urn,omitempty"`

	// Username username
	Username *string `json:"username,omitempty"`

	// Website a URL to the website
	Website *string `json:"website,omitempty"`

	// WebsiteTitle a custom title for the website
	WebsiteTitle *string `json:"website_title,omitempty"`
}

// Users defines model for Users.
type Users struct {
	Collection *[]User `json:"collection,omitempty"`
	NextHref   *string `json:"next_href,omitempty"`
}

// WebProfiles User's links added to their profile
type WebProfiles = []struct {
	// CreatedAt Timestamp of when the link was added to the profile.
	CreatedAt *string `json:"created_at,omitempty"`

	// Kind Kind
	Kind *string `json:"kind,omitempty"`

	// Service Service or platform
	Service *string `json:"service,omitempty"`

	// Title Link's title
	Title *string `json:"title,omitempty"`

	// Url URL of the external link
	Url *string `json:"url,omitempty"`

	// Urn Id
	Urn *string `json:"urn,omitempty"`

	// Username Username extracted from the external link
	Username *string `json:"username,omitempty"`
}

// Access defines model for access.
type Access = []string

// AccessExplicit defines model for access_explicit.
type AccessExplicit = []string

// Bpm defines model for bpm.
type Bpm struct {
	// From Return tracks with at least this bpm value
	From *int `json:"from,omitempty"`

	// To Return tracks with at most this bpm value
	To *int `json:"to,omitempty"`
}

// ClientId defines model for client_id.
type ClientId = string

// CreatedAt defines model for created_at.
type CreatedAt struct {
	// From (yyyy-mm-dd hh:mm:ss) return tracks created at this date or later
	From *string `json:"from,omitempty"`

	// To (yyyy-mm-dd hh:mm:ss) return tracks created at this date or earlier
	To *string `json:"to,omitempty"`
}

// Duration defines model for duration.
type Duration struct {
	// From Return tracks with at least this duration value
	From *int `json:"from,omitempty"`

	// To Return tracks with at most this duration value
	To *int `json:"to,omitempty"`
}

// FakePlaylistUrn defines model for fake_playlist_urn.
type FakePlaylistUrn = string

// FollowerUrn defines model for follower_urn.
type FollowerUrn = string

// FollowingUrn defines model for following_urn.
type FollowingUrn = string

// Genres defines model for genres.
type Genres = string

// Ids defines model for ids.
type Ids = string

// Limit defines model for limit.
type Limit = int

// LinkedPartitioning defines model for linked_partitioning.
type LinkedPartitioning = bool

// Offset defines model for offset.
type Offset = int

// PlaylistUrn defines model for playlist_urn.
type PlaylistUrn = string

// Q defines model for q.
type Q = string

// RedirectUri defines model for redirect_uri.
type RedirectUri = string

// RepostPlaylistUrn defines model for repost_playlist_urn.
type RepostPlaylistUrn = string

// ResponseType defines model for response_type.
type ResponseType string

// SecretToken defines model for secret_token.
type SecretToken = string

// ShowTracks defines model for show_tracks.
type ShowTracks = bool

// State defines model for state.
type State = string

// Tags defines model for tags.
type Tags = string

// TestTrackUrn defines model for test_track_urn.
type TestTrackUrn = string

// TrackUrn defines model for track_urn.
type TrackUrn = string

// Url defines model for url.
type Url = string

// Urns defines model for urns.
type Urns = string

// UserUrn defines model for user_urn.
type UserUrn = string

// UserUrnToFollow defines model for user_urn_to_follow.
type UserUrnToFollow = string

// BadRequest defines model for BadRequest.
type BadRequest = Error

// NotFound defines model for NotFound.
type NotFound = Error

// Success defines model for Success.
type Success interface{}

// Successful defines model for Successful.
type Successful interface{}

// Unauthorized defines model for Unauthorized.
type Unauthorized = Error

// UnprocessableEntity defines model for UnprocessableEntity.
type UnprocessableEntity = Error

// GetConnectParams defines parameters for GetConnect.
type GetConnectParams struct {
	// ClientId The client id belonging to your application
	ClientId ClientId `form:"client_id" json:"client_id"`

	// RedirectUri The redirect uri you have configured for your application
	RedirectUri RedirectUri `form:"redirect_uri" json:"redirect_uri"`

	// ResponseType Support only the Authorization Code Flow
	ResponseType GetConnectParamsResponseType `form:"response_type" json:"response_type"`

	// State Any value included here will be appended to the redirect URI. Use this for CSRF protection.
	State *State `form:"state,omitempty" json:"state,omitempty"`
}

// GetConnectParamsResponseType defines parameters for GetConnect.
type GetConnectParamsResponseType string

// GetMeActivitiesParams defines parameters for GetMeActivities.
type GetMeActivitiesParams struct {
	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMeActivitiesParamsAccess defines parameters for GetMeActivities.
type GetMeActivitiesParamsAccess string

// GetMeActivitiesAllOwnParams defines parameters for GetMeActivitiesAllOwn.
type GetMeActivitiesAllOwnParams struct {
	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMeActivitiesAllOwnParamsAccess defines parameters for GetMeActivitiesAllOwn.
type GetMeActivitiesAllOwnParamsAccess string

// GetMeActivitiesTracksParams defines parameters for GetMeActivitiesTracks.
type GetMeActivitiesTracksParams struct {
	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMeActivitiesTracksParamsAccess defines parameters for GetMeActivitiesTracks.
type GetMeActivitiesTracksParamsAccess string

// GetMeFollowersParams defines parameters for GetMeFollowers.
type GetMeFollowersParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMeFollowingsParams defines parameters for GetMeFollowings.
type GetMeFollowingsParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset of first result. Deprecated, use `linked_partitioning` instead.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetMeFollowingsTracksParams defines parameters for GetMeFollowingsTracks.
type GetMeFollowingsTracksParams struct {
	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset of first result. Deprecated, use `linked_partitioning` instead.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`
}

// GetMeFollowingsTracksParamsAccess defines parameters for GetMeFollowingsTracks.
type GetMeFollowingsTracksParamsAccess string

// GetMeLikesPlaylistsParams defines parameters for GetMeLikesPlaylists.
type GetMeLikesPlaylistsParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetMeLikesTracksParams defines parameters for GetMeLikesTracks.
type GetMeLikesTracksParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *AccessExplicit `form:"access,omitempty" json:"access,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetMeLikesTracksParamsAccess defines parameters for GetMeLikesTracks.
type GetMeLikesTracksParamsAccess string

// GetMePlaylistsParams defines parameters for GetMePlaylists.
type GetMePlaylistsParams struct {
	// ShowTracks A boolean flag to request a playlist with or without tracks. Default is `true`.
	ShowTracks *ShowTracks `form:"show_tracks,omitempty" json:"show_tracks,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetMeTracksParams defines parameters for GetMeTracks.
type GetMeTracksParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetPlaylistsParams defines parameters for GetPlaylists.
type GetPlaylistsParams struct {
	// Q search
	Q *Q `form:"q,omitempty" json:"q,omitempty"`

	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// ShowTracks A boolean flag to request a playlist with or without tracks. Default is `true`.
	ShowTracks *ShowTracks `form:"show_tracks,omitempty" json:"show_tracks,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset of first result. Deprecated, use `linked_partitioning` instead.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetPlaylistsParamsAccess defines parameters for GetPlaylists.
type GetPlaylistsParamsAccess string

// PostPlaylistsMultipartBody defines parameters for PostPlaylists.
type PostPlaylistsMultipartBody struct {
	PlaylistArtworkData   *openapi_types.File                        `json:"playlist[artwork_data],omitempty"`
	PlaylistDescription   *string                                    `json:"playlist[description],omitempty"`
	PlaylistEan           *string                                    `json:"playlist[ean],omitempty"`
	PlaylistGenre         *string                                    `json:"playlist[genre],omitempty"`
	PlaylistLabelName     *string                                    `json:"playlist[label_name],omitempty"`
	PlaylistLicense       *string                                    `json:"playlist[license],omitempty"`
	PlaylistPermalink     *string                                    `json:"playlist[permalink],omitempty"`
	PlaylistPermalinkUrl  *string                                    `json:"playlist[permalink_url],omitempty"`
	PlaylistPurchaseTitle *string                                    `json:"playlist[purchase_title],omitempty"`
	PlaylistPurchaseUrl   *string                                    `json:"playlist[purchase_url],omitempty"`
	PlaylistRelease       *string                                    `json:"playlist[release],omitempty"`
	PlaylistReleaseDate   *string                                    `json:"playlist[release_date],omitempty"`
	PlaylistSetType       *PostPlaylistsMultipartBodyPlaylistSetType `json:"playlist[set_type],omitempty"`
	PlaylistSharing       *PostPlaylistsMultipartBodyPlaylistSharing `json:"playlist[sharing],omitempty"`
	PlaylistTagList       *string                                    `json:"playlist[tag_list],omitempty"`
	PlaylistTitle         string                                     `json:"playlist[title]"`

	// PlaylistTracksUrn To pass multiple tracks, pass multiple comma-separated values, e.g. -F "playlist[tracks][][urn]=soundcloud:tracks:111,soundcloud:tracks:222"
	PlaylistTracksUrn *string `json:"playlist[tracks][][urn],omitempty"`
}

// PostPlaylistsMultipartBodyPlaylistSetType defines parameters for PostPlaylists.
type PostPlaylistsMultipartBodyPlaylistSetType string

// PostPlaylistsMultipartBodyPlaylistSharing defines parameters for PostPlaylists.
type PostPlaylistsMultipartBodyPlaylistSharing string

// GetPlaylistsPlaylistUrnParams defines parameters for GetPlaylistsPlaylistUrn.
type GetPlaylistsPlaylistUrnParams struct {
	// SecretToken A secret token to fetch private playlists/tracks
	SecretToken *SecretToken `form:"secret_token,omitempty" json:"secret_token,omitempty"`

	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// ShowTracks A boolean flag to request a playlist with or without tracks. Default is `true`.
	ShowTracks *ShowTracks `form:"show_tracks,omitempty" json:"show_tracks,omitempty"`
}

// GetPlaylistsPlaylistUrnParamsAccess defines parameters for GetPlaylistsPlaylistUrn.
type GetPlaylistsPlaylistUrnParamsAccess string

// GetPlaylistsPlaylistUrnRepostersParams defines parameters for GetPlaylistsPlaylistUrnReposters.
type GetPlaylistsPlaylistUrnRepostersParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetPlaylistsPlaylistUrnTracksParams defines parameters for GetPlaylistsPlaylistUrnTracks.
type GetPlaylistsPlaylistUrnTracksParams struct {
	// SecretToken A secret token to fetch private playlists/tracks
	SecretToken *SecretToken `form:"secret_token,omitempty" json:"secret_token,omitempty"`

	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetPlaylistsPlaylistUrnTracksParamsAccess defines parameters for GetPlaylistsPlaylistUrnTracks.
type GetPlaylistsPlaylistUrnTracksParamsAccess string

// GetResolveParams defines parameters for GetResolve.
type GetResolveParams struct {
	// Url SoundCloud URL
	Url Url `form:"url" json:"url"`
}

// GetTracksParams defines parameters for GetTracks.
type GetTracksParams struct {
	// Q search
	Q *Q `form:"q,omitempty" json:"q,omitempty"`

	// Ids A comma separated list of track ids to filter on
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Urns A comma separated list of track urns to filter on
	Urns *Urns `form:"urns,omitempty" json:"urns,omitempty"`

	// Genres A comma separated list of genres
	Genres *Genres `form:"genres,omitempty" json:"genres,omitempty"`

	// Tags A comma separated list of tags
	Tags *Tags `form:"tags,omitempty" json:"tags,omitempty"`

	// Bpm Return tracks with a specified bpm[from], bpm[to]
	Bpm *Bpm `json:"bpm,omitempty"`

	// Duration Return tracks within a specified duration range
	Duration *Duration `json:"duration,omitempty"`

	// CreatedAt (yyyy-mm-dd hh:mm:ss) return tracks created within the specified dates
	CreatedAt *CreatedAt `json:"created_at,omitempty"`

	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset of first result. Deprecated, use `linked_partitioning` instead.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetTracksParamsAccess defines parameters for GetTracks.
type GetTracksParamsAccess string

// PostTracksMultipartBody defines parameters for PostTracks.
type PostTracksMultipartBody struct {
	TrackArtworkData  *openapi_types.File `json:"track[artwork_data],omitempty"`
	TrackAssetData    openapi_types.File  `json:"track[asset_data]"`
	TrackCommentable  *bool               `json:"track[commentable],omitempty"`
	TrackDescription  *string             `json:"track[description],omitempty"`
	TrackDownloadable *bool               `json:"track[downloadable],omitempty"`

	// TrackEmbeddableBy who can embed this track "all", "me", or "none"
	TrackEmbeddableBy *PostTracksMultipartBodyTrackEmbeddableBy `json:"track[embeddable_by],omitempty"`
	TrackGenre        *string                                   `json:"track[genre],omitempty"`
	TrackIsrc         *string                                   `json:"track[isrc],omitempty"`
	TrackLabelName    *string                                   `json:"track[label_name],omitempty"`

	// TrackLicense Possible values: no-rights-reserved, all-rights-reserved, cc-by, cc-by-nc, cc-by-nd, cc-by-sa, cc-by-nc-nd, cc-by-nc-sa
	TrackLicense     *PostTracksMultipartBodyTrackLicense `json:"track[license],omitempty"`
	TrackPermalink   *string                              `json:"track[permalink],omitempty"`
	TrackPurchaseUrl *string                              `json:"track[purchase_url],omitempty"`
	TrackRelease     *string                              `json:"track[release],omitempty"`

	// TrackReleaseDate string, formatted as yyyy-mm-dd, representing release date
	TrackReleaseDate *string                              `json:"track[release_date],omitempty"`
	TrackSharing     *PostTracksMultipartBodyTrackSharing `json:"track[sharing],omitempty"`
	TrackStreamable  *bool                                `json:"track[streamable],omitempty"`

	// TrackTagList The tag_list property contains a list of tags separated by spaces. Multiword tags are quoted in double quotes. We also support machine tags that follow the pattern NAMESPACE:KEY=VALUE. For example: geo:lat=43.555 camel:size=medium “machine:tag=with space” Machine tags are not revealed to the user on the track pages.
	TrackTagList *string `json:"track[tag_list],omitempty"`
	TrackTitle   string  `json:"track[title]"`
}

// PostTracksMultipartBodyTrackEmbeddableBy defines parameters for PostTracks.
type PostTracksMultipartBodyTrackEmbeddableBy string

// PostTracksMultipartBodyTrackLicense defines parameters for PostTracks.
type PostTracksMultipartBodyTrackLicense string

// PostTracksMultipartBodyTrackSharing defines parameters for PostTracks.
type PostTracksMultipartBodyTrackSharing string

// GetTracksTrackUrnParams defines parameters for GetTracksTrackUrn.
type GetTracksTrackUrnParams struct {
	// SecretToken A secret token to fetch private playlists/tracks
	SecretToken *SecretToken `form:"secret_token,omitempty" json:"secret_token,omitempty"`
}

// GetTracksTrackUrnCommentsParams defines parameters for GetTracksTrackUrnComments.
type GetTracksTrackUrnCommentsParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset of first result. Deprecated, use `linked_partitioning` instead.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8Body defines parameters for PostTracksTrackUrnComments.
type PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8Body struct {
	Comment *struct {
		// Body Comment's content
		Body string `json:"body"`

		// Timestamp Timestamp of a comment. String or float representation is supported
		Timestamp *PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8Body_Comment_Timestamp `json:"timestamp,omitempty"`
	} `json:"comment,omitempty"`
}

// PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8BodyCommentTimestamp0 defines parameters for PostTracksTrackUrnComments.
type PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8BodyCommentTimestamp0 = string

// PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8BodyCommentTimestamp1 defines parameters for PostTracksTrackUrnComments.
type PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8BodyCommentTimestamp1 = float32

// PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8Body_Comment_Timestamp defines parameters for PostTracksTrackUrnComments.
type PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8Body_Comment_Timestamp struct {
	union json.RawMessage
}

// GetTracksTrackUrnFavoritersParams defines parameters for GetTracksTrackUrnFavoriters.
type GetTracksTrackUrnFavoritersParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetTracksTrackUrnRelatedParams defines parameters for GetTracksTrackUrnRelated.
type GetTracksTrackUrnRelatedParams struct {
	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset of first result. Deprecated, use `linked_partitioning` instead.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetTracksTrackUrnRelatedParamsAccess defines parameters for GetTracksTrackUrnRelated.
type GetTracksTrackUrnRelatedParamsAccess string

// GetTracksTrackUrnRepostersParams defines parameters for GetTracksTrackUrnReposters.
type GetTracksTrackUrnRepostersParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetTracksTrackUrnStreamsParams defines parameters for GetTracksTrackUrnStreams.
type GetTracksTrackUrnStreamsParams struct {
	// SecretToken A secret token to fetch private playlists/tracks
	SecretToken *SecretToken `form:"secret_token,omitempty" json:"secret_token,omitempty"`
}

// GetUsersParams defines parameters for GetUsers.
type GetUsersParams struct {
	// Q search
	Q *Q `form:"q,omitempty" json:"q,omitempty"`

	// Ids A comma separated list of track ids to filter on
	Ids *Ids `form:"ids,omitempty" json:"ids,omitempty"`

	// Urns A comma separated list of track urns to filter on
	Urns *Urns `form:"urns,omitempty" json:"urns,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// Offset Offset of first result. Deprecated, use `linked_partitioning` instead.
	Offset *Offset `form:"offset,omitempty" json:"offset,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetUsersUserUrnFavoritesParams defines parameters for GetUsersUserUrnFavorites.
type GetUsersUserUrnFavoritesParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetUsersUserUrnFollowersParams defines parameters for GetUsersUserUrnFollowers.
type GetUsersUserUrnFollowersParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetUsersUserUrnFollowingsParams defines parameters for GetUsersUserUrnFollowings.
type GetUsersUserUrnFollowingsParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// GetUsersUserUrnLikesPlaylistsParams defines parameters for GetUsersUserUrnLikesPlaylists.
type GetUsersUserUrnLikesPlaylistsParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetUsersUserUrnLikesTracksParams defines parameters for GetUsersUserUrnLikesTracks.
type GetUsersUserUrnLikesTracksParams struct {
	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetUsersUserUrnLikesTracksParamsAccess defines parameters for GetUsersUserUrnLikesTracks.
type GetUsersUserUrnLikesTracksParamsAccess string

// GetUsersUserUrnPlaylistsParams defines parameters for GetUsersUserUrnPlaylists.
type GetUsersUserUrnPlaylistsParams struct {
	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// ShowTracks A boolean flag to request a playlist with or without tracks. Default is `true`.
	ShowTracks *ShowTracks `form:"show_tracks,omitempty" json:"show_tracks,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetUsersUserUrnPlaylistsParamsAccess defines parameters for GetUsersUserUrnPlaylists.
type GetUsersUserUrnPlaylistsParamsAccess string

// GetUsersUserUrnTracksParams defines parameters for GetUsersUserUrnTracks.
type GetUsersUserUrnTracksParams struct {
	// Access Filters content by level of access the user (logged in or anonymous) has to the track. The result list will include only tracks with the specified access. Include all options if you'd like to see all possible tracks. See `Track#access` schema for more details.
	Access *Access `form:"access,omitempty" json:"access,omitempty"`

	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`

	// LinkedPartitioning Returns paginated collection of items (recommended, returning a list without pagination is deprecated and should not be used)
	LinkedPartitioning *LinkedPartitioning `form:"linked_partitioning,omitempty" json:"linked_partitioning,omitempty"`
}

// GetUsersUserUrnTracksParamsAccess defines parameters for GetUsersUserUrnTracks.
type GetUsersUserUrnTracksParamsAccess string

// GetUsersUserUrnWebProfilesParams defines parameters for GetUsersUserUrnWebProfiles.
type GetUsersUserUrnWebProfilesParams struct {
	// Limit Number of results to return in the collection.
	Limit *Limit `form:"limit,omitempty" json:"limit,omitempty"`
}

// PostOauth2TokenFormdataRequestBody defines body for PostOauth2Token for application/x-www-form-urlencoded ContentType.
type PostOauth2TokenFormdataRequestBody = OAuthToken

// PostOauth2TokenMultipartRequestBody defines body for PostOauth2Token for multipart/form-data ContentType.
type PostOauth2TokenMultipartRequestBody = OAuthToken

// PostPlaylistsJSONRequestBody defines body for PostPlaylists for application/json ContentType.
type PostPlaylistsJSONRequestBody = CreateUpdatePlaylistRequest

// PostPlaylistsMultipartRequestBody defines body for PostPlaylists for multipart/form-data ContentType.
type PostPlaylistsMultipartRequestBody PostPlaylistsMultipartBody

// PutPlaylistsPlaylistUrnJSONRequestBody defines body for PutPlaylistsPlaylistUrn for application/json ContentType.
type PutPlaylistsPlaylistUrnJSONRequestBody = CreateUpdatePlaylistRequest

// PostTracksMultipartRequestBody defines body for PostTracks for multipart/x-www-form-urlencoded ContentType.
type PostTracksMultipartRequestBody PostTracksMultipartBody

// PutTracksTrackUrnJSONRequestBody defines body for PutTracksTrackUrn for application/json ContentType.
type PutTracksTrackUrnJSONRequestBody = TrackMetadataRequest

// PutTracksTrackUrnMultipartRequestBody defines body for PutTracksTrackUrn for multipart/x-www-form-urlencoded ContentType.
type PutTracksTrackUrnMultipartRequestBody = TrackDataRequest

// PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8RequestBody defines body for PostTracksTrackUrnComments for application/json; charset=utf-8 ContentType.
type PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8RequestBody PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8Body

// AsTrack returns the union data inside the Activities_Collection_Origin as a Track
func (t Activities_Collection_Origin) AsTrack() (Track, error) {
	var body Track
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromTrack overwrites any union data inside the Activities_Collection_Origin as the provided Track
func (t *Activities_Collection_Origin) FromTrack(v Track) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergeTrack performs a merge with any union data inside the Activities_Collection_Origin, using the provided Track
func (t *Activities_Collection_Origin) MergeTrack(v Track) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

// AsPlaylist returns the union data inside the Activities_Collection_Origin as a Playlist
func (t Activities_Collection_Origin) AsPlaylist() (Playlist, error) {
	var body Playlist
	err := json.Unmarshal(t.union, &body)
	return body, err
}

// FromPlaylist overwrites any union data inside the Activities_Collection_Origin as the provided Playlist
func (t *Activities_Collection_Origin) FromPlaylist(v Playlist) error {
	b, err := json.Marshal(v)
	t.union = b
	return err
}

// MergePlaylist performs a merge with any union data inside the Activities_Collection_Origin, using the provided Playlist
func (t *Activities_Collection_Origin) MergePlaylist(v Playlist) error {
	b, err := json.Marshal(v)
	if err != nil {
		return err
	}

	merged, err := runtime.JSONMerge(t.union, b)
	t.union = merged
	return err
}

func (t Activities_Collection_Origin) MarshalJSON() ([]byte, error) {
	b, err := t.union.MarshalJSON()
	return b, err
}

func (t *Activities_Collection_Origin) UnmarshalJSON(b []byte) error {
	err := t.union.UnmarshalJSON(b)
	return err
}

// RequestEditorFn  is the function signature for the RequestEditor callback function
type RequestEditorFn func(ctx context.Context, req *http.Request) error

// Doer performs HTTP requests.
//
// The standard http.Client implements this interface.
type HttpRequestDoer interface {
	Do(req *http.Request) (*http.Response, error)
}

// Client which conforms to the OpenAPI3 specification for this service.
type Client struct {
	// The endpoint of the server conforming to this interface, with scheme,
	// https://api.deepmap.com for example. This can contain a path relative
	// to the server, such as https://api.deepmap.com/dev-test, and all the
	// paths in the swagger spec will be appended to the server.
	Server string

	// Doer for performing requests, typically a *http.Client with any
	// customized settings, such as certificate chains.
	Client HttpRequestDoer

	// A list of callbacks for modifying requests which are generated before sending over
	// the network.
	RequestEditors []RequestEditorFn
}

// ClientOption allows setting custom parameters during construction
type ClientOption func(*Client) error

// Creates a new Client, with reasonable defaults
func NewClient(server string, opts ...ClientOption) (*Client, error) {
	// create a client with sane default values
	client := Client{
		Server: server,
	}
	// mutate client and add all optional params
	for _, o := range opts {
		if err := o(&client); err != nil {
			return nil, err
		}
	}
	// ensure the server URL always has a trailing slash
	if !strings.HasSuffix(client.Server, "/") {
		client.Server += "/"
	}
	// create httpClient, if not already present
	if client.Client == nil {
		client.Client = &http.Client{}
	}
	return &client, nil
}

// WithHTTPClient allows overriding the default Doer, which is
// automatically created using http.Client. This is useful for tests.
func WithHTTPClient(doer HttpRequestDoer) ClientOption {
	return func(c *Client) error {
		c.Client = doer
		return nil
	}
}

// WithRequestEditorFn allows setting up a callback function, which will be
// called right before sending the request. This can be used to mutate the request.
func WithRequestEditorFn(fn RequestEditorFn) ClientOption {
	return func(c *Client) error {
		c.RequestEditors = append(c.RequestEditors, fn)
		return nil
	}
}

// The interface specification for the client above.
type ClientInterface interface {
	// GetConnect request
	GetConnect(ctx context.Context, params *GetConnectParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLikesPlaylistsPlaylistUrn request
	DeleteLikesPlaylistsPlaylistUrn(ctx context.Context, playlistUrn PlaylistUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLikesPlaylistsPlaylistUrn request
	PostLikesPlaylistsPlaylistUrn(ctx context.Context, playlistUrn PlaylistUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteLikesTracksTrackUrn request
	DeleteLikesTracksTrackUrn(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostLikesTracksTrackUrn request
	PostLikesTracksTrackUrn(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMe request
	GetMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeActivities request
	GetMeActivities(ctx context.Context, params *GetMeActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeActivitiesAllOwn request
	GetMeActivitiesAllOwn(ctx context.Context, params *GetMeActivitiesAllOwnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeActivitiesTracks request
	GetMeActivitiesTracks(ctx context.Context, params *GetMeActivitiesTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeFollowers request
	GetMeFollowers(ctx context.Context, params *GetMeFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeFollowersFollowerUrn request
	GetMeFollowersFollowerUrn(ctx context.Context, followerUrn FollowerUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeFollowings request
	GetMeFollowings(ctx context.Context, params *GetMeFollowingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeFollowingsTracks request
	GetMeFollowingsTracks(ctx context.Context, params *GetMeFollowingsTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteMeFollowingsUserUrn request
	DeleteMeFollowingsUserUrn(ctx context.Context, userUrn UserUrnToFollow, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeFollowingsUserUrn request
	GetMeFollowingsUserUrn(ctx context.Context, userUrn UserUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutMeFollowingsUserUrn request
	PutMeFollowingsUserUrn(ctx context.Context, userUrn UserUrnToFollow, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeLikesPlaylists request
	GetMeLikesPlaylists(ctx context.Context, params *GetMeLikesPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeLikesTracks request
	GetMeLikesTracks(ctx context.Context, params *GetMeLikesTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMePlaylists request
	GetMePlaylists(ctx context.Context, params *GetMePlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetMeTracks request
	GetMeTracks(ctx context.Context, params *GetMeTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostOauth2TokenWithBody request with any body
	PostOauth2TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostOauth2TokenWithFormdataBody(ctx context.Context, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaylists request
	GetPlaylists(ctx context.Context, params *GetPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostPlaylistsWithBody request with any body
	PostPlaylistsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostPlaylists(ctx context.Context, body PostPlaylistsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeletePlaylistsPlaylistUrn request
	DeletePlaylistsPlaylistUrn(ctx context.Context, playlistUrn FakePlaylistUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaylistsPlaylistUrn request
	GetPlaylistsPlaylistUrn(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutPlaylistsPlaylistUrnWithBody request with any body
	PutPlaylistsPlaylistUrnWithBody(ctx context.Context, playlistUrn FakePlaylistUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutPlaylistsPlaylistUrn(ctx context.Context, playlistUrn FakePlaylistUrn, body PutPlaylistsPlaylistUrnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaylistsPlaylistUrnReposters request
	GetPlaylistsPlaylistUrnReposters(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnRepostersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetPlaylistsPlaylistUrnTracks request
	GetPlaylistsPlaylistUrnTracks(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepostsPlaylistsPlaylistUrn request
	DeleteRepostsPlaylistsPlaylistUrn(ctx context.Context, playlistUrn RepostPlaylistUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRepostsPlaylistsPlaylistUrn request
	PostRepostsPlaylistsPlaylistUrn(ctx context.Context, playlistUrn RepostPlaylistUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteRepostsTracksTrackUrn request
	DeleteRepostsTracksTrackUrn(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostRepostsTracksTrackUrn request
	PostRepostsTracksTrackUrn(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetResolve request
	GetResolve(ctx context.Context, params *GetResolveParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostSignOut request
	PostSignOut(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTracks request
	GetTracks(ctx context.Context, params *GetTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTracksWithBody request with any body
	PostTracksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	// DeleteTracksTrackUrn request
	DeleteTracksTrackUrn(ctx context.Context, trackUrn TrackUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTracksTrackUrn request
	GetTracksTrackUrn(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PutTracksTrackUrnWithBody request with any body
	PutTracksTrackUrnWithBody(ctx context.Context, trackUrn TrackUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PutTracksTrackUrn(ctx context.Context, trackUrn TrackUrn, body PutTracksTrackUrnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTracksTrackUrnComments request
	GetTracksTrackUrnComments(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// PostTracksTrackUrnCommentsWithBody request with any body
	PostTracksTrackUrnCommentsWithBody(ctx context.Context, trackUrn TrackUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error)

	PostTracksTrackUrnCommentsWithApplicationJSONCharsetUTF8Body(ctx context.Context, trackUrn TrackUrn, body PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8RequestBody, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTracksTrackUrnFavoriters request
	GetTracksTrackUrnFavoriters(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnFavoritersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTracksTrackUrnRelated request
	GetTracksTrackUrnRelated(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnRelatedParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTracksTrackUrnReposters request
	GetTracksTrackUrnReposters(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnRepostersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetTracksTrackUrnStreams request
	GetTracksTrackUrnStreams(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsers request
	GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUserUrn request
	GetUsersUserUrn(ctx context.Context, userUrn UserUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUserUrnFavorites request
	GetUsersUserUrnFavorites(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFavoritesParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUserUrnFollowers request
	GetUsersUserUrnFollowers(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUserUrnFollowings request
	GetUsersUserUrnFollowings(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFollowingsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUserUrnFollowingsFollowingUrn request
	GetUsersUserUrnFollowingsFollowingUrn(ctx context.Context, userUrn UserUrn, followingUrn FollowingUrn, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUserUrnLikesPlaylists request
	GetUsersUserUrnLikesPlaylists(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnLikesPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUserUrnLikesTracks request
	GetUsersUserUrnLikesTracks(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnLikesTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUserUrnPlaylists request
	GetUsersUserUrnPlaylists(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUserUrnTracks request
	GetUsersUserUrnTracks(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error)

	// GetUsersUserUrnWebProfiles request
	GetUsersUserUrnWebProfiles(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnWebProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error)
}

func (c *Client) GetConnect(ctx context.Context, params *GetConnectParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetConnectRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLikesPlaylistsPlaylistUrn(ctx context.Context, playlistUrn PlaylistUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLikesPlaylistsPlaylistUrnRequest(c.Server, playlistUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLikesPlaylistsPlaylistUrn(ctx context.Context, playlistUrn PlaylistUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLikesPlaylistsPlaylistUrnRequest(c.Server, playlistUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteLikesTracksTrackUrn(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteLikesTracksTrackUrnRequest(c.Server, trackUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostLikesTracksTrackUrn(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostLikesTracksTrackUrnRequest(c.Server, trackUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMe(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeActivities(ctx context.Context, params *GetMeActivitiesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeActivitiesRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeActivitiesAllOwn(ctx context.Context, params *GetMeActivitiesAllOwnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeActivitiesAllOwnRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeActivitiesTracks(ctx context.Context, params *GetMeActivitiesTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeActivitiesTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeFollowers(ctx context.Context, params *GetMeFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeFollowersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeFollowersFollowerUrn(ctx context.Context, followerUrn FollowerUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeFollowersFollowerUrnRequest(c.Server, followerUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeFollowings(ctx context.Context, params *GetMeFollowingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeFollowingsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeFollowingsTracks(ctx context.Context, params *GetMeFollowingsTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeFollowingsTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteMeFollowingsUserUrn(ctx context.Context, userUrn UserUrnToFollow, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteMeFollowingsUserUrnRequest(c.Server, userUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeFollowingsUserUrn(ctx context.Context, userUrn UserUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeFollowingsUserUrnRequest(c.Server, userUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutMeFollowingsUserUrn(ctx context.Context, userUrn UserUrnToFollow, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutMeFollowingsUserUrnRequest(c.Server, userUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeLikesPlaylists(ctx context.Context, params *GetMeLikesPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeLikesPlaylistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeLikesTracks(ctx context.Context, params *GetMeLikesTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeLikesTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMePlaylists(ctx context.Context, params *GetMePlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMePlaylistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetMeTracks(ctx context.Context, params *GetMeTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetMeTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOauth2TokenWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOauth2TokenRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostOauth2TokenWithFormdataBody(ctx context.Context, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostOauth2TokenRequestWithFormdataBody(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaylists(ctx context.Context, params *GetPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaylistsRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPlaylistsWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPlaylistsRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostPlaylists(ctx context.Context, body PostPlaylistsJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostPlaylistsRequest(c.Server, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeletePlaylistsPlaylistUrn(ctx context.Context, playlistUrn FakePlaylistUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeletePlaylistsPlaylistUrnRequest(c.Server, playlistUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaylistsPlaylistUrn(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaylistsPlaylistUrnRequest(c.Server, playlistUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPlaylistsPlaylistUrnWithBody(ctx context.Context, playlistUrn FakePlaylistUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPlaylistsPlaylistUrnRequestWithBody(c.Server, playlistUrn, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutPlaylistsPlaylistUrn(ctx context.Context, playlistUrn FakePlaylistUrn, body PutPlaylistsPlaylistUrnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutPlaylistsPlaylistUrnRequest(c.Server, playlistUrn, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaylistsPlaylistUrnReposters(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnRepostersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaylistsPlaylistUrnRepostersRequest(c.Server, playlistUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetPlaylistsPlaylistUrnTracks(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetPlaylistsPlaylistUrnTracksRequest(c.Server, playlistUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepostsPlaylistsPlaylistUrn(ctx context.Context, playlistUrn RepostPlaylistUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepostsPlaylistsPlaylistUrnRequest(c.Server, playlistUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRepostsPlaylistsPlaylistUrn(ctx context.Context, playlistUrn RepostPlaylistUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRepostsPlaylistsPlaylistUrnRequest(c.Server, playlistUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteRepostsTracksTrackUrn(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteRepostsTracksTrackUrnRequest(c.Server, trackUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostRepostsTracksTrackUrn(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostRepostsTracksTrackUrnRequest(c.Server, trackUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetResolve(ctx context.Context, params *GetResolveParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetResolveRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostSignOut(ctx context.Context, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostSignOutRequest(c.Server)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTracks(ctx context.Context, params *GetTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTracksRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTracksWithBody(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTracksRequestWithBody(c.Server, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) DeleteTracksTrackUrn(ctx context.Context, trackUrn TrackUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewDeleteTracksTrackUrnRequest(c.Server, trackUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTracksTrackUrn(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTracksTrackUrnRequest(c.Server, trackUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTracksTrackUrnWithBody(ctx context.Context, trackUrn TrackUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTracksTrackUrnRequestWithBody(c.Server, trackUrn, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PutTracksTrackUrn(ctx context.Context, trackUrn TrackUrn, body PutTracksTrackUrnJSONRequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPutTracksTrackUrnRequest(c.Server, trackUrn, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTracksTrackUrnComments(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnCommentsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTracksTrackUrnCommentsRequest(c.Server, trackUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTracksTrackUrnCommentsWithBody(ctx context.Context, trackUrn TrackUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTracksTrackUrnCommentsRequestWithBody(c.Server, trackUrn, contentType, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) PostTracksTrackUrnCommentsWithApplicationJSONCharsetUTF8Body(ctx context.Context, trackUrn TrackUrn, body PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8RequestBody, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewPostTracksTrackUrnCommentsRequestWithApplicationJSONCharsetUTF8Body(c.Server, trackUrn, body)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTracksTrackUrnFavoriters(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnFavoritersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTracksTrackUrnFavoritersRequest(c.Server, trackUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTracksTrackUrnRelated(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnRelatedParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTracksTrackUrnRelatedRequest(c.Server, trackUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTracksTrackUrnReposters(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnRepostersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTracksTrackUrnRepostersRequest(c.Server, trackUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetTracksTrackUrnStreams(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnStreamsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetTracksTrackUrnStreamsRequest(c.Server, trackUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsers(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersRequest(c.Server, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersUserUrn(ctx context.Context, userUrn UserUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserUrnRequest(c.Server, userUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersUserUrnFavorites(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFavoritesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserUrnFavoritesRequest(c.Server, userUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersUserUrnFollowers(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFollowersParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserUrnFollowersRequest(c.Server, userUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersUserUrnFollowings(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFollowingsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserUrnFollowingsRequest(c.Server, userUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersUserUrnFollowingsFollowingUrn(ctx context.Context, userUrn UserUrn, followingUrn FollowingUrn, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserUrnFollowingsFollowingUrnRequest(c.Server, userUrn, followingUrn)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersUserUrnLikesPlaylists(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnLikesPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserUrnLikesPlaylistsRequest(c.Server, userUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersUserUrnLikesTracks(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnLikesTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserUrnLikesTracksRequest(c.Server, userUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersUserUrnPlaylists(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnPlaylistsParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserUrnPlaylistsRequest(c.Server, userUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersUserUrnTracks(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnTracksParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserUrnTracksRequest(c.Server, userUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

func (c *Client) GetUsersUserUrnWebProfiles(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnWebProfilesParams, reqEditors ...RequestEditorFn) (*http.Response, error) {
	req, err := NewGetUsersUserUrnWebProfilesRequest(c.Server, userUrn, params)
	if err != nil {
		return nil, err
	}
	req = req.WithContext(ctx)
	if err := c.applyEditors(ctx, req, reqEditors); err != nil {
		return nil, err
	}
	return c.Client.Do(req)
}

// NewGetConnectRequest generates requests for GetConnect
func NewGetConnectRequest(server string, params *GetConnectParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/connect")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "client_id", runtime.ParamLocationQuery, params.ClientId); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "redirect_uri", runtime.ParamLocationQuery, params.RedirectUri); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "response_type", runtime.ParamLocationQuery, params.ResponseType); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		if params.State != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "state", runtime.ParamLocationQuery, *params.State); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteLikesPlaylistsPlaylistUrnRequest generates requests for DeleteLikesPlaylistsPlaylistUrn
func NewDeleteLikesPlaylistsPlaylistUrnRequest(server string, playlistUrn PlaylistUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_urn", runtime.ParamLocationPath, playlistUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/likes/playlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLikesPlaylistsPlaylistUrnRequest generates requests for PostLikesPlaylistsPlaylistUrn
func NewPostLikesPlaylistsPlaylistUrnRequest(server string, playlistUrn PlaylistUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_urn", runtime.ParamLocationPath, playlistUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/likes/playlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteLikesTracksTrackUrnRequest generates requests for DeleteLikesTracksTrackUrn
func NewDeleteLikesTracksTrackUrnRequest(server string, trackUrn TestTrackUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/likes/tracks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostLikesTracksTrackUrnRequest generates requests for PostLikesTracksTrackUrn
func NewPostLikesTracksTrackUrnRequest(server string, trackUrn TestTrackUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/likes/tracks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeRequest generates requests for GetMe
func NewGetMeRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeActivitiesRequest generates requests for GetMeActivities
func NewGetMeActivitiesRequest(server string, params *GetMeActivitiesParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/activities")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeActivitiesAllOwnRequest generates requests for GetMeActivitiesAllOwn
func NewGetMeActivitiesAllOwnRequest(server string, params *GetMeActivitiesAllOwnParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/activities/all/own")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeActivitiesTracksRequest generates requests for GetMeActivitiesTracks
func NewGetMeActivitiesTracksRequest(server string, params *GetMeActivitiesTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/activities/tracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeFollowersRequest generates requests for GetMeFollowers
func NewGetMeFollowersRequest(server string, params *GetMeFollowersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/followers")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeFollowersFollowerUrnRequest generates requests for GetMeFollowersFollowerUrn
func NewGetMeFollowersFollowerUrnRequest(server string, followerUrn FollowerUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "follower_urn", runtime.ParamLocationPath, followerUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/followers/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeFollowingsRequest generates requests for GetMeFollowings
func NewGetMeFollowingsRequest(server string, params *GetMeFollowingsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/followings")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeFollowingsTracksRequest generates requests for GetMeFollowingsTracks
func NewGetMeFollowingsTracksRequest(server string, params *GetMeFollowingsTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/followings/tracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteMeFollowingsUserUrnRequest generates requests for DeleteMeFollowingsUserUrn
func NewDeleteMeFollowingsUserUrnRequest(server string, userUrn UserUrnToFollow) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/followings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeFollowingsUserUrnRequest generates requests for GetMeFollowingsUserUrn
func NewGetMeFollowingsUserUrnRequest(server string, userUrn UserUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/followings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutMeFollowingsUserUrnRequest generates requests for PutMeFollowingsUserUrn
func NewPutMeFollowingsUserUrnRequest(server string, userUrn UserUrnToFollow) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/followings/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeLikesPlaylistsRequest generates requests for GetMeLikesPlaylists
func NewGetMeLikesPlaylistsRequest(server string, params *GetMeLikesPlaylistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/likes/playlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeLikesTracksRequest generates requests for GetMeLikesTracks
func NewGetMeLikesTracksRequest(server string, params *GetMeLikesTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/likes/tracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMePlaylistsRequest generates requests for GetMePlaylists
func NewGetMePlaylistsRequest(server string, params *GetMePlaylistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/playlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.ShowTracks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_tracks", runtime.ParamLocationQuery, *params.ShowTracks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetMeTracksRequest generates requests for GetMeTracks
func NewGetMeTracksRequest(server string, params *GetMeTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/me/tracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostOauth2TokenRequestWithFormdataBody calls the generic PostOauth2Token builder with application/x-www-form-urlencoded body
func NewPostOauth2TokenRequestWithFormdataBody(server string, body PostOauth2TokenFormdataRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	bodyStr, err := runtime.MarshalForm(body, nil)
	if err != nil {
		return nil, err
	}
	bodyReader = strings.NewReader(bodyStr.Encode())
	return NewPostOauth2TokenRequestWithBody(server, "application/x-www-form-urlencoded", bodyReader)
}

// NewPostOauth2TokenRequestWithBody generates requests for PostOauth2Token with any type of body
func NewPostOauth2TokenRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/oauth2/token")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlaylistsRequest generates requests for GetPlaylists
func NewGetPlaylistsRequest(server string, params *GetPlaylistsParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowTracks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_tracks", runtime.ParamLocationQuery, *params.ShowTracks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostPlaylistsRequest calls the generic PostPlaylists builder with application/json body
func NewPostPlaylistsRequest(server string, body PostPlaylistsJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostPlaylistsRequestWithBody(server, "application/json", bodyReader)
}

// NewPostPlaylistsRequestWithBody generates requests for PostPlaylists with any type of body
func NewPostPlaylistsRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeletePlaylistsPlaylistUrnRequest generates requests for DeletePlaylistsPlaylistUrn
func NewDeletePlaylistsPlaylistUrnRequest(server string, playlistUrn FakePlaylistUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_urn", runtime.ParamLocationPath, playlistUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaylistsPlaylistUrnRequest generates requests for GetPlaylistsPlaylistUrn
func NewGetPlaylistsPlaylistUrnRequest(server string, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_urn", runtime.ParamLocationPath, playlistUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SecretToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret_token", runtime.ParamLocationQuery, *params.SecretToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowTracks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_tracks", runtime.ParamLocationQuery, *params.ShowTracks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutPlaylistsPlaylistUrnRequest calls the generic PutPlaylistsPlaylistUrn builder with application/json body
func NewPutPlaylistsPlaylistUrnRequest(server string, playlistUrn FakePlaylistUrn, body PutPlaylistsPlaylistUrnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutPlaylistsPlaylistUrnRequestWithBody(server, playlistUrn, "application/json", bodyReader)
}

// NewPutPlaylistsPlaylistUrnRequestWithBody generates requests for PutPlaylistsPlaylistUrn with any type of body
func NewPutPlaylistsPlaylistUrnRequestWithBody(server string, playlistUrn FakePlaylistUrn, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_urn", runtime.ParamLocationPath, playlistUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetPlaylistsPlaylistUrnRepostersRequest generates requests for GetPlaylistsPlaylistUrnReposters
func NewGetPlaylistsPlaylistUrnRepostersRequest(server string, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnRepostersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_urn", runtime.ParamLocationPath, playlistUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s/reposters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetPlaylistsPlaylistUrnTracksRequest generates requests for GetPlaylistsPlaylistUrnTracks
func NewGetPlaylistsPlaylistUrnTracksRequest(server string, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnTracksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_urn", runtime.ParamLocationPath, playlistUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/playlists/%s/tracks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SecretToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret_token", runtime.ParamLocationQuery, *params.SecretToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRepostsPlaylistsPlaylistUrnRequest generates requests for DeleteRepostsPlaylistsPlaylistUrn
func NewDeleteRepostsPlaylistsPlaylistUrnRequest(server string, playlistUrn RepostPlaylistUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_urn", runtime.ParamLocationPath, playlistUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reposts/playlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRepostsPlaylistsPlaylistUrnRequest generates requests for PostRepostsPlaylistsPlaylistUrn
func NewPostRepostsPlaylistsPlaylistUrnRequest(server string, playlistUrn RepostPlaylistUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "playlist_urn", runtime.ParamLocationPath, playlistUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reposts/playlists/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewDeleteRepostsTracksTrackUrnRequest generates requests for DeleteRepostsTracksTrackUrn
func NewDeleteRepostsTracksTrackUrnRequest(server string, trackUrn TestTrackUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reposts/tracks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostRepostsTracksTrackUrnRequest generates requests for PostRepostsTracksTrackUrn
func NewPostRepostsTracksTrackUrnRequest(server string, trackUrn TestTrackUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/reposts/tracks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetResolveRequest generates requests for GetResolve
func NewGetResolveRequest(server string, params *GetResolveParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/resolve")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if queryFrag, err := runtime.StyleParamWithLocation("form", true, "url", runtime.ParamLocationQuery, params.Url); err != nil {
			return nil, err
		} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
			return nil, err
		} else {
			for k, v := range parsed {
				for _, v2 := range v {
					queryValues.Add(k, v2)
				}
			}
		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostSignOutRequest generates requests for PostSignOut
func NewPostSignOutRequest(server string) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/sign-out")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTracksRequest generates requests for GetTracks
func NewGetTracksRequest(server string, params *GetTracksParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Urns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "urns", runtime.ParamLocationQuery, *params.Urns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Genres != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "genres", runtime.ParamLocationQuery, *params.Genres); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Tags != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "tags", runtime.ParamLocationQuery, *params.Tags); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Bpm != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "bpm", runtime.ParamLocationQuery, *params.Bpm); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Duration != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "duration", runtime.ParamLocationQuery, *params.Duration); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.CreatedAt != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("deepObject", true, "created_at", runtime.ParamLocationQuery, *params.CreatedAt); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTracksRequestWithBody generates requests for PostTracks with any type of body
func NewPostTracksRequestWithBody(server string, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewDeleteTracksTrackUrnRequest generates requests for DeleteTracksTrackUrn
func NewDeleteTracksTrackUrnRequest(server string, trackUrn TrackUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("DELETE", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTracksTrackUrnRequest generates requests for GetTracksTrackUrn
func NewGetTracksTrackUrnRequest(server string, trackUrn TrackUrn, params *GetTracksTrackUrnParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SecretToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret_token", runtime.ParamLocationQuery, *params.SecretToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPutTracksTrackUrnRequest calls the generic PutTracksTrackUrn builder with application/json body
func NewPutTracksTrackUrnRequest(server string, trackUrn TrackUrn, body PutTracksTrackUrnJSONRequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPutTracksTrackUrnRequestWithBody(server, trackUrn, "application/json", bodyReader)
}

// NewPutTracksTrackUrnRequestWithBody generates requests for PutTracksTrackUrn with any type of body
func NewPutTracksTrackUrnRequestWithBody(server string, trackUrn TrackUrn, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("PUT", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTracksTrackUrnCommentsRequest generates requests for GetTracksTrackUrnComments
func NewGetTracksTrackUrnCommentsRequest(server string, trackUrn TrackUrn, params *GetTracksTrackUrnCommentsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewPostTracksTrackUrnCommentsRequestWithApplicationJSONCharsetUTF8Body calls the generic PostTracksTrackUrnComments builder with application/json; charset=utf-8 body
func NewPostTracksTrackUrnCommentsRequestWithApplicationJSONCharsetUTF8Body(server string, trackUrn TrackUrn, body PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8RequestBody) (*http.Request, error) {
	var bodyReader io.Reader
	buf, err := json.Marshal(body)
	if err != nil {
		return nil, err
	}
	bodyReader = bytes.NewReader(buf)
	return NewPostTracksTrackUrnCommentsRequestWithBody(server, trackUrn, "application/json; charset=utf-8", bodyReader)
}

// NewPostTracksTrackUrnCommentsRequestWithBody generates requests for PostTracksTrackUrnComments with any type of body
func NewPostTracksTrackUrnCommentsRequestWithBody(server string, trackUrn TrackUrn, contentType string, body io.Reader) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks/%s/comments", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("POST", queryURL.String(), body)
	if err != nil {
		return nil, err
	}

	req.Header.Add("Content-Type", contentType)

	return req, nil
}

// NewGetTracksTrackUrnFavoritersRequest generates requests for GetTracksTrackUrnFavoriters
func NewGetTracksTrackUrnFavoritersRequest(server string, trackUrn TrackUrn, params *GetTracksTrackUrnFavoritersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks/%s/favoriters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTracksTrackUrnRelatedRequest generates requests for GetTracksTrackUrnRelated
func NewGetTracksTrackUrnRelatedRequest(server string, trackUrn TrackUrn, params *GetTracksTrackUrnRelatedParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks/%s/related", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTracksTrackUrnRepostersRequest generates requests for GetTracksTrackUrnReposters
func NewGetTracksTrackUrnRepostersRequest(server string, trackUrn TrackUrn, params *GetTracksTrackUrnRepostersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks/%s/reposters", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetTracksTrackUrnStreamsRequest generates requests for GetTracksTrackUrnStreams
func NewGetTracksTrackUrnStreamsRequest(server string, trackUrn TrackUrn, params *GetTracksTrackUrnStreamsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "track_urn", runtime.ParamLocationPath, trackUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/tracks/%s/streams", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.SecretToken != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "secret_token", runtime.ParamLocationQuery, *params.SecretToken); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersRequest generates requests for GetUsers
func NewGetUsersRequest(server string, params *GetUsersParams) (*http.Request, error) {
	var err error

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users")
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Q != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "q", runtime.ParamLocationQuery, *params.Q); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Ids != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "ids", runtime.ParamLocationQuery, *params.Ids); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Urns != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "urns", runtime.ParamLocationQuery, *params.Urns); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Offset != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "offset", runtime.ParamLocationQuery, *params.Offset); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserUrnRequest generates requests for GetUsersUserUrn
func NewGetUsersUserUrnRequest(server string, userUrn UserUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserUrnFavoritesRequest generates requests for GetUsersUserUrnFavorites
func NewGetUsersUserUrnFavoritesRequest(server string, userUrn UserUrn, params *GetUsersUserUrnFavoritesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/favorites", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserUrnFollowersRequest generates requests for GetUsersUserUrnFollowers
func NewGetUsersUserUrnFollowersRequest(server string, userUrn UserUrn, params *GetUsersUserUrnFollowersParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/followers", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserUrnFollowingsRequest generates requests for GetUsersUserUrnFollowings
func NewGetUsersUserUrnFollowingsRequest(server string, userUrn UserUrn, params *GetUsersUserUrnFollowingsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/followings", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserUrnFollowingsFollowingUrnRequest generates requests for GetUsersUserUrnFollowingsFollowingUrn
func NewGetUsersUserUrnFollowingsFollowingUrnRequest(server string, userUrn UserUrn, followingUrn FollowingUrn) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	var pathParam1 string

	pathParam1, err = runtime.StyleParamWithLocation("simple", false, "following_urn", runtime.ParamLocationPath, followingUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/followings/%s", pathParam0, pathParam1)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserUrnLikesPlaylistsRequest generates requests for GetUsersUserUrnLikesPlaylists
func NewGetUsersUserUrnLikesPlaylistsRequest(server string, userUrn UserUrn, params *GetUsersUserUrnLikesPlaylistsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/likes/playlists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserUrnLikesTracksRequest generates requests for GetUsersUserUrnLikesTracks
func NewGetUsersUserUrnLikesTracksRequest(server string, userUrn UserUrn, params *GetUsersUserUrnLikesTracksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/likes/tracks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserUrnPlaylistsRequest generates requests for GetUsersUserUrnPlaylists
func NewGetUsersUserUrnPlaylistsRequest(server string, userUrn UserUrn, params *GetUsersUserUrnPlaylistsParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/playlists", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.ShowTracks != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "show_tracks", runtime.ParamLocationQuery, *params.ShowTracks); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserUrnTracksRequest generates requests for GetUsersUserUrnTracks
func NewGetUsersUserUrnTracksRequest(server string, userUrn UserUrn, params *GetUsersUserUrnTracksParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/tracks", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Access != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", false, "access", runtime.ParamLocationQuery, *params.Access); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		if params.LinkedPartitioning != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "linked_partitioning", runtime.ParamLocationQuery, *params.LinkedPartitioning); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

// NewGetUsersUserUrnWebProfilesRequest generates requests for GetUsersUserUrnWebProfiles
func NewGetUsersUserUrnWebProfilesRequest(server string, userUrn UserUrn, params *GetUsersUserUrnWebProfilesParams) (*http.Request, error) {
	var err error

	var pathParam0 string

	pathParam0, err = runtime.StyleParamWithLocation("simple", false, "user_urn", runtime.ParamLocationPath, userUrn)
	if err != nil {
		return nil, err
	}

	serverURL, err := url.Parse(server)
	if err != nil {
		return nil, err
	}

	operationPath := fmt.Sprintf("/users/%s/web-profiles", pathParam0)
	if operationPath[0] == '/' {
		operationPath = "." + operationPath
	}

	queryURL, err := serverURL.Parse(operationPath)
	if err != nil {
		return nil, err
	}

	if params != nil {
		queryValues := queryURL.Query()

		if params.Limit != nil {

			if queryFrag, err := runtime.StyleParamWithLocation("form", true, "limit", runtime.ParamLocationQuery, *params.Limit); err != nil {
				return nil, err
			} else if parsed, err := url.ParseQuery(queryFrag); err != nil {
				return nil, err
			} else {
				for k, v := range parsed {
					for _, v2 := range v {
						queryValues.Add(k, v2)
					}
				}
			}

		}

		queryURL.RawQuery = queryValues.Encode()
	}

	req, err := http.NewRequest("GET", queryURL.String(), nil)
	if err != nil {
		return nil, err
	}

	return req, nil
}

func (c *Client) applyEditors(ctx context.Context, req *http.Request, additionalEditors []RequestEditorFn) error {
	for _, r := range c.RequestEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	for _, r := range additionalEditors {
		if err := r(ctx, req); err != nil {
			return err
		}
	}
	return nil
}

// ClientWithResponses builds on ClientInterface to offer response payloads
type ClientWithResponses struct {
	ClientInterface
}

// NewClientWithResponses creates a new ClientWithResponses, which wraps
// Client with return type handling
func NewClientWithResponses(server string, opts ...ClientOption) (*ClientWithResponses, error) {
	client, err := NewClient(server, opts...)
	if err != nil {
		return nil, err
	}
	return &ClientWithResponses{client}, nil
}

// WithBaseURL overrides the baseURL.
func WithBaseURL(baseURL string) ClientOption {
	return func(c *Client) error {
		newBaseURL, err := url.Parse(baseURL)
		if err != nil {
			return err
		}
		c.Server = newBaseURL.String()
		return nil
	}
}

// ClientWithResponsesInterface is the interface specification for the client with responses above.
type ClientWithResponsesInterface interface {
	// GetConnectWithResponse request
	GetConnectWithResponse(ctx context.Context, params *GetConnectParams, reqEditors ...RequestEditorFn) (*GetConnectResponse, error)

	// DeleteLikesPlaylistsPlaylistUrnWithResponse request
	DeleteLikesPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn PlaylistUrn, reqEditors ...RequestEditorFn) (*DeleteLikesPlaylistsPlaylistUrnResponse, error)

	// PostLikesPlaylistsPlaylistUrnWithResponse request
	PostLikesPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn PlaylistUrn, reqEditors ...RequestEditorFn) (*PostLikesPlaylistsPlaylistUrnResponse, error)

	// DeleteLikesTracksTrackUrnWithResponse request
	DeleteLikesTracksTrackUrnWithResponse(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*DeleteLikesTracksTrackUrnResponse, error)

	// PostLikesTracksTrackUrnWithResponse request
	PostLikesTracksTrackUrnWithResponse(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*PostLikesTracksTrackUrnResponse, error)

	// GetMeWithResponse request
	GetMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMeResponse, error)

	// GetMeActivitiesWithResponse request
	GetMeActivitiesWithResponse(ctx context.Context, params *GetMeActivitiesParams, reqEditors ...RequestEditorFn) (*GetMeActivitiesResponse, error)

	// GetMeActivitiesAllOwnWithResponse request
	GetMeActivitiesAllOwnWithResponse(ctx context.Context, params *GetMeActivitiesAllOwnParams, reqEditors ...RequestEditorFn) (*GetMeActivitiesAllOwnResponse, error)

	// GetMeActivitiesTracksWithResponse request
	GetMeActivitiesTracksWithResponse(ctx context.Context, params *GetMeActivitiesTracksParams, reqEditors ...RequestEditorFn) (*GetMeActivitiesTracksResponse, error)

	// GetMeFollowersWithResponse request
	GetMeFollowersWithResponse(ctx context.Context, params *GetMeFollowersParams, reqEditors ...RequestEditorFn) (*GetMeFollowersResponse, error)

	// GetMeFollowersFollowerUrnWithResponse request
	GetMeFollowersFollowerUrnWithResponse(ctx context.Context, followerUrn FollowerUrn, reqEditors ...RequestEditorFn) (*GetMeFollowersFollowerUrnResponse, error)

	// GetMeFollowingsWithResponse request
	GetMeFollowingsWithResponse(ctx context.Context, params *GetMeFollowingsParams, reqEditors ...RequestEditorFn) (*GetMeFollowingsResponse, error)

	// GetMeFollowingsTracksWithResponse request
	GetMeFollowingsTracksWithResponse(ctx context.Context, params *GetMeFollowingsTracksParams, reqEditors ...RequestEditorFn) (*GetMeFollowingsTracksResponse, error)

	// DeleteMeFollowingsUserUrnWithResponse request
	DeleteMeFollowingsUserUrnWithResponse(ctx context.Context, userUrn UserUrnToFollow, reqEditors ...RequestEditorFn) (*DeleteMeFollowingsUserUrnResponse, error)

	// GetMeFollowingsUserUrnWithResponse request
	GetMeFollowingsUserUrnWithResponse(ctx context.Context, userUrn UserUrn, reqEditors ...RequestEditorFn) (*GetMeFollowingsUserUrnResponse, error)

	// PutMeFollowingsUserUrnWithResponse request
	PutMeFollowingsUserUrnWithResponse(ctx context.Context, userUrn UserUrnToFollow, reqEditors ...RequestEditorFn) (*PutMeFollowingsUserUrnResponse, error)

	// GetMeLikesPlaylistsWithResponse request
	GetMeLikesPlaylistsWithResponse(ctx context.Context, params *GetMeLikesPlaylistsParams, reqEditors ...RequestEditorFn) (*GetMeLikesPlaylistsResponse, error)

	// GetMeLikesTracksWithResponse request
	GetMeLikesTracksWithResponse(ctx context.Context, params *GetMeLikesTracksParams, reqEditors ...RequestEditorFn) (*GetMeLikesTracksResponse, error)

	// GetMePlaylistsWithResponse request
	GetMePlaylistsWithResponse(ctx context.Context, params *GetMePlaylistsParams, reqEditors ...RequestEditorFn) (*GetMePlaylistsResponse, error)

	// GetMeTracksWithResponse request
	GetMeTracksWithResponse(ctx context.Context, params *GetMeTracksParams, reqEditors ...RequestEditorFn) (*GetMeTracksResponse, error)

	// PostOauth2TokenWithBodyWithResponse request with any body
	PostOauth2TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOauth2TokenResponse, error)

	PostOauth2TokenWithFormdataBodyWithResponse(ctx context.Context, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOauth2TokenResponse, error)

	// GetPlaylistsWithResponse request
	GetPlaylistsWithResponse(ctx context.Context, params *GetPlaylistsParams, reqEditors ...RequestEditorFn) (*GetPlaylistsResponse, error)

	// PostPlaylistsWithBodyWithResponse request with any body
	PostPlaylistsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPlaylistsResponse, error)

	PostPlaylistsWithResponse(ctx context.Context, body PostPlaylistsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPlaylistsResponse, error)

	// DeletePlaylistsPlaylistUrnWithResponse request
	DeletePlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn FakePlaylistUrn, reqEditors ...RequestEditorFn) (*DeletePlaylistsPlaylistUrnResponse, error)

	// GetPlaylistsPlaylistUrnWithResponse request
	GetPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnParams, reqEditors ...RequestEditorFn) (*GetPlaylistsPlaylistUrnResponse, error)

	// PutPlaylistsPlaylistUrnWithBodyWithResponse request with any body
	PutPlaylistsPlaylistUrnWithBodyWithResponse(ctx context.Context, playlistUrn FakePlaylistUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPlaylistsPlaylistUrnResponse, error)

	PutPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn FakePlaylistUrn, body PutPlaylistsPlaylistUrnJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPlaylistsPlaylistUrnResponse, error)

	// GetPlaylistsPlaylistUrnRepostersWithResponse request
	GetPlaylistsPlaylistUrnRepostersWithResponse(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnRepostersParams, reqEditors ...RequestEditorFn) (*GetPlaylistsPlaylistUrnRepostersResponse, error)

	// GetPlaylistsPlaylistUrnTracksWithResponse request
	GetPlaylistsPlaylistUrnTracksWithResponse(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnTracksParams, reqEditors ...RequestEditorFn) (*GetPlaylistsPlaylistUrnTracksResponse, error)

	// DeleteRepostsPlaylistsPlaylistUrnWithResponse request
	DeleteRepostsPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn RepostPlaylistUrn, reqEditors ...RequestEditorFn) (*DeleteRepostsPlaylistsPlaylistUrnResponse, error)

	// PostRepostsPlaylistsPlaylistUrnWithResponse request
	PostRepostsPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn RepostPlaylistUrn, reqEditors ...RequestEditorFn) (*PostRepostsPlaylistsPlaylistUrnResponse, error)

	// DeleteRepostsTracksTrackUrnWithResponse request
	DeleteRepostsTracksTrackUrnWithResponse(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*DeleteRepostsTracksTrackUrnResponse, error)

	// PostRepostsTracksTrackUrnWithResponse request
	PostRepostsTracksTrackUrnWithResponse(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*PostRepostsTracksTrackUrnResponse, error)

	// GetResolveWithResponse request
	GetResolveWithResponse(ctx context.Context, params *GetResolveParams, reqEditors ...RequestEditorFn) (*GetResolveResponse, error)

	// PostSignOutWithResponse request
	PostSignOutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSignOutResponse, error)

	// GetTracksWithResponse request
	GetTracksWithResponse(ctx context.Context, params *GetTracksParams, reqEditors ...RequestEditorFn) (*GetTracksResponse, error)

	// PostTracksWithBodyWithResponse request with any body
	PostTracksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTracksResponse, error)

	// DeleteTracksTrackUrnWithResponse request
	DeleteTracksTrackUrnWithResponse(ctx context.Context, trackUrn TrackUrn, reqEditors ...RequestEditorFn) (*DeleteTracksTrackUrnResponse, error)

	// GetTracksTrackUrnWithResponse request
	GetTracksTrackUrnWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnResponse, error)

	// PutTracksTrackUrnWithBodyWithResponse request with any body
	PutTracksTrackUrnWithBodyWithResponse(ctx context.Context, trackUrn TrackUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTracksTrackUrnResponse, error)

	PutTracksTrackUrnWithResponse(ctx context.Context, trackUrn TrackUrn, body PutTracksTrackUrnJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTracksTrackUrnResponse, error)

	// GetTracksTrackUrnCommentsWithResponse request
	GetTracksTrackUrnCommentsWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnCommentsParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnCommentsResponse, error)

	// PostTracksTrackUrnCommentsWithBodyWithResponse request with any body
	PostTracksTrackUrnCommentsWithBodyWithResponse(ctx context.Context, trackUrn TrackUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTracksTrackUrnCommentsResponse, error)

	PostTracksTrackUrnCommentsWithApplicationJSONCharsetUTF8BodyWithResponse(ctx context.Context, trackUrn TrackUrn, body PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8RequestBody, reqEditors ...RequestEditorFn) (*PostTracksTrackUrnCommentsResponse, error)

	// GetTracksTrackUrnFavoritersWithResponse request
	GetTracksTrackUrnFavoritersWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnFavoritersParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnFavoritersResponse, error)

	// GetTracksTrackUrnRelatedWithResponse request
	GetTracksTrackUrnRelatedWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnRelatedParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnRelatedResponse, error)

	// GetTracksTrackUrnRepostersWithResponse request
	GetTracksTrackUrnRepostersWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnRepostersParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnRepostersResponse, error)

	// GetTracksTrackUrnStreamsWithResponse request
	GetTracksTrackUrnStreamsWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnStreamsParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnStreamsResponse, error)

	// GetUsersWithResponse request
	GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error)

	// GetUsersUserUrnWithResponse request
	GetUsersUserUrnWithResponse(ctx context.Context, userUrn UserUrn, reqEditors ...RequestEditorFn) (*GetUsersUserUrnResponse, error)

	// GetUsersUserUrnFavoritesWithResponse request
	GetUsersUserUrnFavoritesWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFavoritesParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnFavoritesResponse, error)

	// GetUsersUserUrnFollowersWithResponse request
	GetUsersUserUrnFollowersWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFollowersParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnFollowersResponse, error)

	// GetUsersUserUrnFollowingsWithResponse request
	GetUsersUserUrnFollowingsWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFollowingsParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnFollowingsResponse, error)

	// GetUsersUserUrnFollowingsFollowingUrnWithResponse request
	GetUsersUserUrnFollowingsFollowingUrnWithResponse(ctx context.Context, userUrn UserUrn, followingUrn FollowingUrn, reqEditors ...RequestEditorFn) (*GetUsersUserUrnFollowingsFollowingUrnResponse, error)

	// GetUsersUserUrnLikesPlaylistsWithResponse request
	GetUsersUserUrnLikesPlaylistsWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnLikesPlaylistsParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnLikesPlaylistsResponse, error)

	// GetUsersUserUrnLikesTracksWithResponse request
	GetUsersUserUrnLikesTracksWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnLikesTracksParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnLikesTracksResponse, error)

	// GetUsersUserUrnPlaylistsWithResponse request
	GetUsersUserUrnPlaylistsWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnPlaylistsParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnPlaylistsResponse, error)

	// GetUsersUserUrnTracksWithResponse request
	GetUsersUserUrnTracksWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnTracksParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnTracksResponse, error)

	// GetUsersUserUrnWebProfilesWithResponse request
	GetUsersUserUrnWebProfilesWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnWebProfilesParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnWebProfilesResponse, error)
}

type GetConnectResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetConnectResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetConnectResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLikesPlaylistsPlaylistUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8400 *BadRequest
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteLikesPlaylistsPlaylistUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLikesPlaylistsPlaylistUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLikesPlaylistsPlaylistUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8400 *BadRequest
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
	JSON429                       *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r PostLikesPlaylistsPlaylistUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLikesPlaylistsPlaylistUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteLikesTracksTrackUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8400 *BadRequest
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteLikesTracksTrackUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteLikesTracksTrackUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostLikesTracksTrackUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8400 *BadRequest
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
	JSON429                       *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r PostLikesTracksTrackUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostLikesTracksTrackUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Me
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetMeResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeActivitiesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Activities
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetMeActivitiesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeActivitiesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeActivitiesAllOwnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Activities
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetMeActivitiesAllOwnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeActivitiesAllOwnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeActivitiesTracksResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Activities
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetMeActivitiesTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeActivitiesTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeFollowersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Users
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetMeFollowersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeFollowersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeFollowersFollowerUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *User
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetMeFollowersFollowerUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeFollowersFollowerUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeFollowingsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Users
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetMeFollowingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeFollowingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeFollowingsTracksResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *TracksList
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetMeFollowingsTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeFollowingsTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteMeFollowingsUserUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
	JSON422                       *UnprocessableEntity
}

// Status returns HTTPResponse.Status
func (r DeleteMeFollowingsUserUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteMeFollowingsUserUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeFollowingsUserUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *User
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetMeFollowingsUserUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeFollowingsUserUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutMeFollowingsUserUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8201 *User
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r PutMeFollowingsUserUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutMeFollowingsUserUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeLikesPlaylistsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetMeLikesPlaylistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeLikesPlaylistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeLikesTracksResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetMeLikesTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeLikesTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMePlaylistsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetMePlaylistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMePlaylistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetMeTracksResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetMeTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetMeTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostOauth2TokenResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON400      *struct {
		union json.RawMessage
	}
	JSON401 *struct {
		union json.RawMessage
	}
}

// Status returns HTTPResponse.Status
func (r PostOauth2TokenResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostOauth2TokenResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaylistsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8400 *BadRequest
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetPlaylistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaylistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostPlaylistsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8201 *Playlist
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r PostPlaylistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostPlaylistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeletePlaylistsPlaylistUrnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeletePlaylistsPlaylistUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeletePlaylistsPlaylistUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaylistsPlaylistUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Playlist
	ApplicationjsonCharsetUtf8400 *BadRequest
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetPlaylistsPlaylistUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaylistsPlaylistUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutPlaylistsPlaylistUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Playlist
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r PutPlaylistsPlaylistUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutPlaylistsPlaylistUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaylistsPlaylistUrnRepostersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Users
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetPlaylistsPlaylistUrnRepostersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaylistsPlaylistUrnRepostersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetPlaylistsPlaylistUrnTracksResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8400 *BadRequest
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetPlaylistsPlaylistUrnTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetPlaylistsPlaylistUrnTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepostsPlaylistsPlaylistUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteRepostsPlaylistsPlaylistUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepostsPlaylistsPlaylistUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRepostsPlaylistsPlaylistUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r PostRepostsPlaylistsPlaylistUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRepostsPlaylistsPlaylistUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteRepostsTracksTrackUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteRepostsTracksTrackUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteRepostsTracksTrackUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostRepostsTracksTrackUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r PostRepostsTracksTrackUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostRepostsTracksTrackUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetResolveResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8302 *Found
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetResolveResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetResolveResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostSignOutResponse struct {
	Body         []byte
	HTTPResponse *http.Response
}

// Status returns HTTPResponse.Status
func (r PostSignOutResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostSignOutResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTracksResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8400 *BadRequest
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTracksResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8201 *Track
	ApplicationjsonCharsetUtf8400 *BadRequest
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON422                       *UnprocessableEntity
}

// Status returns HTTPResponse.Status
func (r PostTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type DeleteTracksTrackUrnResponse struct {
	Body         []byte
	HTTPResponse *http.Response
	JSON404      *NotFound
}

// Status returns HTTPResponse.Status
func (r DeleteTracksTrackUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r DeleteTracksTrackUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTracksTrackUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Track
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTracksTrackUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTracksTrackUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PutTracksTrackUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Track
	ApplicationjsonCharsetUtf8400 *BadRequest
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r PutTracksTrackUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PutTracksTrackUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTracksTrackUrnCommentsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Comments
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTracksTrackUrnCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTracksTrackUrnCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type PostTracksTrackUrnCommentsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8201 *Comment
	JSON422                       *UnprocessableEntity
	JSON429                       *TooManyRequests
}

// Status returns HTTPResponse.Status
func (r PostTracksTrackUrnCommentsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r PostTracksTrackUrnCommentsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTracksTrackUrnFavoritersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Users
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTracksTrackUrnFavoritersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTracksTrackUrnFavoritersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTracksTrackUrnRelatedResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTracksTrackUrnRelatedResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTracksTrackUrnRelatedResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTracksTrackUrnRepostersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Users
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTracksTrackUrnRepostersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTracksTrackUrnRepostersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetTracksTrackUrnStreamsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Streams
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetTracksTrackUrnStreamsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetTracksTrackUrnStreamsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Users
	ApplicationjsonCharsetUtf8400 *BadRequest
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *User
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUsersUserUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserUrnFavoritesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersUserUrnFavoritesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserUrnFavoritesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserUrnFollowersResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Users
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersUserUrnFollowersResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserUrnFollowersResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserUrnFollowingsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *Users
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersUserUrnFollowingsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserUrnFollowingsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserUrnFollowingsFollowingUrnResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *User
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUsersUserUrnFollowingsFollowingUrnResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserUrnFollowingsFollowingUrnResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserUrnLikesPlaylistsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8400 *BadRequest
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUsersUserUrnLikesPlaylistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserUrnLikesPlaylistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserUrnLikesTracksResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8400 *BadRequest
	ApplicationjsonCharsetUtf8401 *Unauthorized
	JSON404                       *NotFound
}

// Status returns HTTPResponse.Status
func (r GetUsersUserUrnLikesTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserUrnLikesTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserUrnPlaylistsResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersUserUrnPlaylistsResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserUrnPlaylistsResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserUrnTracksResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *struct {
		union json.RawMessage
	}
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersUserUrnTracksResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserUrnTracksResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

type GetUsersUserUrnWebProfilesResponse struct {
	Body                          []byte
	HTTPResponse                  *http.Response
	ApplicationjsonCharsetUtf8200 *WebProfiles
	ApplicationjsonCharsetUtf8401 *Unauthorized
}

// Status returns HTTPResponse.Status
func (r GetUsersUserUrnWebProfilesResponse) Status() string {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.Status
	}
	return http.StatusText(0)
}

// StatusCode returns HTTPResponse.StatusCode
func (r GetUsersUserUrnWebProfilesResponse) StatusCode() int {
	if r.HTTPResponse != nil {
		return r.HTTPResponse.StatusCode
	}
	return 0
}

// GetConnectWithResponse request returning *GetConnectResponse
func (c *ClientWithResponses) GetConnectWithResponse(ctx context.Context, params *GetConnectParams, reqEditors ...RequestEditorFn) (*GetConnectResponse, error) {
	rsp, err := c.GetConnect(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetConnectResponse(rsp)
}

// DeleteLikesPlaylistsPlaylistUrnWithResponse request returning *DeleteLikesPlaylistsPlaylistUrnResponse
func (c *ClientWithResponses) DeleteLikesPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn PlaylistUrn, reqEditors ...RequestEditorFn) (*DeleteLikesPlaylistsPlaylistUrnResponse, error) {
	rsp, err := c.DeleteLikesPlaylistsPlaylistUrn(ctx, playlistUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLikesPlaylistsPlaylistUrnResponse(rsp)
}

// PostLikesPlaylistsPlaylistUrnWithResponse request returning *PostLikesPlaylistsPlaylistUrnResponse
func (c *ClientWithResponses) PostLikesPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn PlaylistUrn, reqEditors ...RequestEditorFn) (*PostLikesPlaylistsPlaylistUrnResponse, error) {
	rsp, err := c.PostLikesPlaylistsPlaylistUrn(ctx, playlistUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLikesPlaylistsPlaylistUrnResponse(rsp)
}

// DeleteLikesTracksTrackUrnWithResponse request returning *DeleteLikesTracksTrackUrnResponse
func (c *ClientWithResponses) DeleteLikesTracksTrackUrnWithResponse(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*DeleteLikesTracksTrackUrnResponse, error) {
	rsp, err := c.DeleteLikesTracksTrackUrn(ctx, trackUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteLikesTracksTrackUrnResponse(rsp)
}

// PostLikesTracksTrackUrnWithResponse request returning *PostLikesTracksTrackUrnResponse
func (c *ClientWithResponses) PostLikesTracksTrackUrnWithResponse(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*PostLikesTracksTrackUrnResponse, error) {
	rsp, err := c.PostLikesTracksTrackUrn(ctx, trackUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostLikesTracksTrackUrnResponse(rsp)
}

// GetMeWithResponse request returning *GetMeResponse
func (c *ClientWithResponses) GetMeWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*GetMeResponse, error) {
	rsp, err := c.GetMe(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeResponse(rsp)
}

// GetMeActivitiesWithResponse request returning *GetMeActivitiesResponse
func (c *ClientWithResponses) GetMeActivitiesWithResponse(ctx context.Context, params *GetMeActivitiesParams, reqEditors ...RequestEditorFn) (*GetMeActivitiesResponse, error) {
	rsp, err := c.GetMeActivities(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeActivitiesResponse(rsp)
}

// GetMeActivitiesAllOwnWithResponse request returning *GetMeActivitiesAllOwnResponse
func (c *ClientWithResponses) GetMeActivitiesAllOwnWithResponse(ctx context.Context, params *GetMeActivitiesAllOwnParams, reqEditors ...RequestEditorFn) (*GetMeActivitiesAllOwnResponse, error) {
	rsp, err := c.GetMeActivitiesAllOwn(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeActivitiesAllOwnResponse(rsp)
}

// GetMeActivitiesTracksWithResponse request returning *GetMeActivitiesTracksResponse
func (c *ClientWithResponses) GetMeActivitiesTracksWithResponse(ctx context.Context, params *GetMeActivitiesTracksParams, reqEditors ...RequestEditorFn) (*GetMeActivitiesTracksResponse, error) {
	rsp, err := c.GetMeActivitiesTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeActivitiesTracksResponse(rsp)
}

// GetMeFollowersWithResponse request returning *GetMeFollowersResponse
func (c *ClientWithResponses) GetMeFollowersWithResponse(ctx context.Context, params *GetMeFollowersParams, reqEditors ...RequestEditorFn) (*GetMeFollowersResponse, error) {
	rsp, err := c.GetMeFollowers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeFollowersResponse(rsp)
}

// GetMeFollowersFollowerUrnWithResponse request returning *GetMeFollowersFollowerUrnResponse
func (c *ClientWithResponses) GetMeFollowersFollowerUrnWithResponse(ctx context.Context, followerUrn FollowerUrn, reqEditors ...RequestEditorFn) (*GetMeFollowersFollowerUrnResponse, error) {
	rsp, err := c.GetMeFollowersFollowerUrn(ctx, followerUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeFollowersFollowerUrnResponse(rsp)
}

// GetMeFollowingsWithResponse request returning *GetMeFollowingsResponse
func (c *ClientWithResponses) GetMeFollowingsWithResponse(ctx context.Context, params *GetMeFollowingsParams, reqEditors ...RequestEditorFn) (*GetMeFollowingsResponse, error) {
	rsp, err := c.GetMeFollowings(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeFollowingsResponse(rsp)
}

// GetMeFollowingsTracksWithResponse request returning *GetMeFollowingsTracksResponse
func (c *ClientWithResponses) GetMeFollowingsTracksWithResponse(ctx context.Context, params *GetMeFollowingsTracksParams, reqEditors ...RequestEditorFn) (*GetMeFollowingsTracksResponse, error) {
	rsp, err := c.GetMeFollowingsTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeFollowingsTracksResponse(rsp)
}

// DeleteMeFollowingsUserUrnWithResponse request returning *DeleteMeFollowingsUserUrnResponse
func (c *ClientWithResponses) DeleteMeFollowingsUserUrnWithResponse(ctx context.Context, userUrn UserUrnToFollow, reqEditors ...RequestEditorFn) (*DeleteMeFollowingsUserUrnResponse, error) {
	rsp, err := c.DeleteMeFollowingsUserUrn(ctx, userUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteMeFollowingsUserUrnResponse(rsp)
}

// GetMeFollowingsUserUrnWithResponse request returning *GetMeFollowingsUserUrnResponse
func (c *ClientWithResponses) GetMeFollowingsUserUrnWithResponse(ctx context.Context, userUrn UserUrn, reqEditors ...RequestEditorFn) (*GetMeFollowingsUserUrnResponse, error) {
	rsp, err := c.GetMeFollowingsUserUrn(ctx, userUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeFollowingsUserUrnResponse(rsp)
}

// PutMeFollowingsUserUrnWithResponse request returning *PutMeFollowingsUserUrnResponse
func (c *ClientWithResponses) PutMeFollowingsUserUrnWithResponse(ctx context.Context, userUrn UserUrnToFollow, reqEditors ...RequestEditorFn) (*PutMeFollowingsUserUrnResponse, error) {
	rsp, err := c.PutMeFollowingsUserUrn(ctx, userUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutMeFollowingsUserUrnResponse(rsp)
}

// GetMeLikesPlaylistsWithResponse request returning *GetMeLikesPlaylistsResponse
func (c *ClientWithResponses) GetMeLikesPlaylistsWithResponse(ctx context.Context, params *GetMeLikesPlaylistsParams, reqEditors ...RequestEditorFn) (*GetMeLikesPlaylistsResponse, error) {
	rsp, err := c.GetMeLikesPlaylists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeLikesPlaylistsResponse(rsp)
}

// GetMeLikesTracksWithResponse request returning *GetMeLikesTracksResponse
func (c *ClientWithResponses) GetMeLikesTracksWithResponse(ctx context.Context, params *GetMeLikesTracksParams, reqEditors ...RequestEditorFn) (*GetMeLikesTracksResponse, error) {
	rsp, err := c.GetMeLikesTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeLikesTracksResponse(rsp)
}

// GetMePlaylistsWithResponse request returning *GetMePlaylistsResponse
func (c *ClientWithResponses) GetMePlaylistsWithResponse(ctx context.Context, params *GetMePlaylistsParams, reqEditors ...RequestEditorFn) (*GetMePlaylistsResponse, error) {
	rsp, err := c.GetMePlaylists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMePlaylistsResponse(rsp)
}

// GetMeTracksWithResponse request returning *GetMeTracksResponse
func (c *ClientWithResponses) GetMeTracksWithResponse(ctx context.Context, params *GetMeTracksParams, reqEditors ...RequestEditorFn) (*GetMeTracksResponse, error) {
	rsp, err := c.GetMeTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetMeTracksResponse(rsp)
}

// PostOauth2TokenWithBodyWithResponse request with arbitrary body returning *PostOauth2TokenResponse
func (c *ClientWithResponses) PostOauth2TokenWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostOauth2TokenResponse, error) {
	rsp, err := c.PostOauth2TokenWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOauth2TokenResponse(rsp)
}

func (c *ClientWithResponses) PostOauth2TokenWithFormdataBodyWithResponse(ctx context.Context, body PostOauth2TokenFormdataRequestBody, reqEditors ...RequestEditorFn) (*PostOauth2TokenResponse, error) {
	rsp, err := c.PostOauth2TokenWithFormdataBody(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostOauth2TokenResponse(rsp)
}

// GetPlaylistsWithResponse request returning *GetPlaylistsResponse
func (c *ClientWithResponses) GetPlaylistsWithResponse(ctx context.Context, params *GetPlaylistsParams, reqEditors ...RequestEditorFn) (*GetPlaylistsResponse, error) {
	rsp, err := c.GetPlaylists(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaylistsResponse(rsp)
}

// PostPlaylistsWithBodyWithResponse request with arbitrary body returning *PostPlaylistsResponse
func (c *ClientWithResponses) PostPlaylistsWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostPlaylistsResponse, error) {
	rsp, err := c.PostPlaylistsWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPlaylistsResponse(rsp)
}

func (c *ClientWithResponses) PostPlaylistsWithResponse(ctx context.Context, body PostPlaylistsJSONRequestBody, reqEditors ...RequestEditorFn) (*PostPlaylistsResponse, error) {
	rsp, err := c.PostPlaylists(ctx, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostPlaylistsResponse(rsp)
}

// DeletePlaylistsPlaylistUrnWithResponse request returning *DeletePlaylistsPlaylistUrnResponse
func (c *ClientWithResponses) DeletePlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn FakePlaylistUrn, reqEditors ...RequestEditorFn) (*DeletePlaylistsPlaylistUrnResponse, error) {
	rsp, err := c.DeletePlaylistsPlaylistUrn(ctx, playlistUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeletePlaylistsPlaylistUrnResponse(rsp)
}

// GetPlaylistsPlaylistUrnWithResponse request returning *GetPlaylistsPlaylistUrnResponse
func (c *ClientWithResponses) GetPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnParams, reqEditors ...RequestEditorFn) (*GetPlaylistsPlaylistUrnResponse, error) {
	rsp, err := c.GetPlaylistsPlaylistUrn(ctx, playlistUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaylistsPlaylistUrnResponse(rsp)
}

// PutPlaylistsPlaylistUrnWithBodyWithResponse request with arbitrary body returning *PutPlaylistsPlaylistUrnResponse
func (c *ClientWithResponses) PutPlaylistsPlaylistUrnWithBodyWithResponse(ctx context.Context, playlistUrn FakePlaylistUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutPlaylistsPlaylistUrnResponse, error) {
	rsp, err := c.PutPlaylistsPlaylistUrnWithBody(ctx, playlistUrn, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPlaylistsPlaylistUrnResponse(rsp)
}

func (c *ClientWithResponses) PutPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn FakePlaylistUrn, body PutPlaylistsPlaylistUrnJSONRequestBody, reqEditors ...RequestEditorFn) (*PutPlaylistsPlaylistUrnResponse, error) {
	rsp, err := c.PutPlaylistsPlaylistUrn(ctx, playlistUrn, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutPlaylistsPlaylistUrnResponse(rsp)
}

// GetPlaylistsPlaylistUrnRepostersWithResponse request returning *GetPlaylistsPlaylistUrnRepostersResponse
func (c *ClientWithResponses) GetPlaylistsPlaylistUrnRepostersWithResponse(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnRepostersParams, reqEditors ...RequestEditorFn) (*GetPlaylistsPlaylistUrnRepostersResponse, error) {
	rsp, err := c.GetPlaylistsPlaylistUrnReposters(ctx, playlistUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaylistsPlaylistUrnRepostersResponse(rsp)
}

// GetPlaylistsPlaylistUrnTracksWithResponse request returning *GetPlaylistsPlaylistUrnTracksResponse
func (c *ClientWithResponses) GetPlaylistsPlaylistUrnTracksWithResponse(ctx context.Context, playlistUrn PlaylistUrn, params *GetPlaylistsPlaylistUrnTracksParams, reqEditors ...RequestEditorFn) (*GetPlaylistsPlaylistUrnTracksResponse, error) {
	rsp, err := c.GetPlaylistsPlaylistUrnTracks(ctx, playlistUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetPlaylistsPlaylistUrnTracksResponse(rsp)
}

// DeleteRepostsPlaylistsPlaylistUrnWithResponse request returning *DeleteRepostsPlaylistsPlaylistUrnResponse
func (c *ClientWithResponses) DeleteRepostsPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn RepostPlaylistUrn, reqEditors ...RequestEditorFn) (*DeleteRepostsPlaylistsPlaylistUrnResponse, error) {
	rsp, err := c.DeleteRepostsPlaylistsPlaylistUrn(ctx, playlistUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepostsPlaylistsPlaylistUrnResponse(rsp)
}

// PostRepostsPlaylistsPlaylistUrnWithResponse request returning *PostRepostsPlaylistsPlaylistUrnResponse
func (c *ClientWithResponses) PostRepostsPlaylistsPlaylistUrnWithResponse(ctx context.Context, playlistUrn RepostPlaylistUrn, reqEditors ...RequestEditorFn) (*PostRepostsPlaylistsPlaylistUrnResponse, error) {
	rsp, err := c.PostRepostsPlaylistsPlaylistUrn(ctx, playlistUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRepostsPlaylistsPlaylistUrnResponse(rsp)
}

// DeleteRepostsTracksTrackUrnWithResponse request returning *DeleteRepostsTracksTrackUrnResponse
func (c *ClientWithResponses) DeleteRepostsTracksTrackUrnWithResponse(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*DeleteRepostsTracksTrackUrnResponse, error) {
	rsp, err := c.DeleteRepostsTracksTrackUrn(ctx, trackUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteRepostsTracksTrackUrnResponse(rsp)
}

// PostRepostsTracksTrackUrnWithResponse request returning *PostRepostsTracksTrackUrnResponse
func (c *ClientWithResponses) PostRepostsTracksTrackUrnWithResponse(ctx context.Context, trackUrn TestTrackUrn, reqEditors ...RequestEditorFn) (*PostRepostsTracksTrackUrnResponse, error) {
	rsp, err := c.PostRepostsTracksTrackUrn(ctx, trackUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostRepostsTracksTrackUrnResponse(rsp)
}

// GetResolveWithResponse request returning *GetResolveResponse
func (c *ClientWithResponses) GetResolveWithResponse(ctx context.Context, params *GetResolveParams, reqEditors ...RequestEditorFn) (*GetResolveResponse, error) {
	rsp, err := c.GetResolve(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetResolveResponse(rsp)
}

// PostSignOutWithResponse request returning *PostSignOutResponse
func (c *ClientWithResponses) PostSignOutWithResponse(ctx context.Context, reqEditors ...RequestEditorFn) (*PostSignOutResponse, error) {
	rsp, err := c.PostSignOut(ctx, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostSignOutResponse(rsp)
}

// GetTracksWithResponse request returning *GetTracksResponse
func (c *ClientWithResponses) GetTracksWithResponse(ctx context.Context, params *GetTracksParams, reqEditors ...RequestEditorFn) (*GetTracksResponse, error) {
	rsp, err := c.GetTracks(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTracksResponse(rsp)
}

// PostTracksWithBodyWithResponse request with arbitrary body returning *PostTracksResponse
func (c *ClientWithResponses) PostTracksWithBodyWithResponse(ctx context.Context, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTracksResponse, error) {
	rsp, err := c.PostTracksWithBody(ctx, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTracksResponse(rsp)
}

// DeleteTracksTrackUrnWithResponse request returning *DeleteTracksTrackUrnResponse
func (c *ClientWithResponses) DeleteTracksTrackUrnWithResponse(ctx context.Context, trackUrn TrackUrn, reqEditors ...RequestEditorFn) (*DeleteTracksTrackUrnResponse, error) {
	rsp, err := c.DeleteTracksTrackUrn(ctx, trackUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseDeleteTracksTrackUrnResponse(rsp)
}

// GetTracksTrackUrnWithResponse request returning *GetTracksTrackUrnResponse
func (c *ClientWithResponses) GetTracksTrackUrnWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnResponse, error) {
	rsp, err := c.GetTracksTrackUrn(ctx, trackUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTracksTrackUrnResponse(rsp)
}

// PutTracksTrackUrnWithBodyWithResponse request with arbitrary body returning *PutTracksTrackUrnResponse
func (c *ClientWithResponses) PutTracksTrackUrnWithBodyWithResponse(ctx context.Context, trackUrn TrackUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PutTracksTrackUrnResponse, error) {
	rsp, err := c.PutTracksTrackUrnWithBody(ctx, trackUrn, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTracksTrackUrnResponse(rsp)
}

func (c *ClientWithResponses) PutTracksTrackUrnWithResponse(ctx context.Context, trackUrn TrackUrn, body PutTracksTrackUrnJSONRequestBody, reqEditors ...RequestEditorFn) (*PutTracksTrackUrnResponse, error) {
	rsp, err := c.PutTracksTrackUrn(ctx, trackUrn, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePutTracksTrackUrnResponse(rsp)
}

// GetTracksTrackUrnCommentsWithResponse request returning *GetTracksTrackUrnCommentsResponse
func (c *ClientWithResponses) GetTracksTrackUrnCommentsWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnCommentsParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnCommentsResponse, error) {
	rsp, err := c.GetTracksTrackUrnComments(ctx, trackUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTracksTrackUrnCommentsResponse(rsp)
}

// PostTracksTrackUrnCommentsWithBodyWithResponse request with arbitrary body returning *PostTracksTrackUrnCommentsResponse
func (c *ClientWithResponses) PostTracksTrackUrnCommentsWithBodyWithResponse(ctx context.Context, trackUrn TrackUrn, contentType string, body io.Reader, reqEditors ...RequestEditorFn) (*PostTracksTrackUrnCommentsResponse, error) {
	rsp, err := c.PostTracksTrackUrnCommentsWithBody(ctx, trackUrn, contentType, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTracksTrackUrnCommentsResponse(rsp)
}

func (c *ClientWithResponses) PostTracksTrackUrnCommentsWithApplicationJSONCharsetUTF8BodyWithResponse(ctx context.Context, trackUrn TrackUrn, body PostTracksTrackUrnCommentsApplicationJSONCharsetUTF8RequestBody, reqEditors ...RequestEditorFn) (*PostTracksTrackUrnCommentsResponse, error) {
	rsp, err := c.PostTracksTrackUrnCommentsWithApplicationJSONCharsetUTF8Body(ctx, trackUrn, body, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParsePostTracksTrackUrnCommentsResponse(rsp)
}

// GetTracksTrackUrnFavoritersWithResponse request returning *GetTracksTrackUrnFavoritersResponse
func (c *ClientWithResponses) GetTracksTrackUrnFavoritersWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnFavoritersParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnFavoritersResponse, error) {
	rsp, err := c.GetTracksTrackUrnFavoriters(ctx, trackUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTracksTrackUrnFavoritersResponse(rsp)
}

// GetTracksTrackUrnRelatedWithResponse request returning *GetTracksTrackUrnRelatedResponse
func (c *ClientWithResponses) GetTracksTrackUrnRelatedWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnRelatedParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnRelatedResponse, error) {
	rsp, err := c.GetTracksTrackUrnRelated(ctx, trackUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTracksTrackUrnRelatedResponse(rsp)
}

// GetTracksTrackUrnRepostersWithResponse request returning *GetTracksTrackUrnRepostersResponse
func (c *ClientWithResponses) GetTracksTrackUrnRepostersWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnRepostersParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnRepostersResponse, error) {
	rsp, err := c.GetTracksTrackUrnReposters(ctx, trackUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTracksTrackUrnRepostersResponse(rsp)
}

// GetTracksTrackUrnStreamsWithResponse request returning *GetTracksTrackUrnStreamsResponse
func (c *ClientWithResponses) GetTracksTrackUrnStreamsWithResponse(ctx context.Context, trackUrn TrackUrn, params *GetTracksTrackUrnStreamsParams, reqEditors ...RequestEditorFn) (*GetTracksTrackUrnStreamsResponse, error) {
	rsp, err := c.GetTracksTrackUrnStreams(ctx, trackUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetTracksTrackUrnStreamsResponse(rsp)
}

// GetUsersWithResponse request returning *GetUsersResponse
func (c *ClientWithResponses) GetUsersWithResponse(ctx context.Context, params *GetUsersParams, reqEditors ...RequestEditorFn) (*GetUsersResponse, error) {
	rsp, err := c.GetUsers(ctx, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersResponse(rsp)
}

// GetUsersUserUrnWithResponse request returning *GetUsersUserUrnResponse
func (c *ClientWithResponses) GetUsersUserUrnWithResponse(ctx context.Context, userUrn UserUrn, reqEditors ...RequestEditorFn) (*GetUsersUserUrnResponse, error) {
	rsp, err := c.GetUsersUserUrn(ctx, userUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserUrnResponse(rsp)
}

// GetUsersUserUrnFavoritesWithResponse request returning *GetUsersUserUrnFavoritesResponse
func (c *ClientWithResponses) GetUsersUserUrnFavoritesWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFavoritesParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnFavoritesResponse, error) {
	rsp, err := c.GetUsersUserUrnFavorites(ctx, userUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserUrnFavoritesResponse(rsp)
}

// GetUsersUserUrnFollowersWithResponse request returning *GetUsersUserUrnFollowersResponse
func (c *ClientWithResponses) GetUsersUserUrnFollowersWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFollowersParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnFollowersResponse, error) {
	rsp, err := c.GetUsersUserUrnFollowers(ctx, userUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserUrnFollowersResponse(rsp)
}

// GetUsersUserUrnFollowingsWithResponse request returning *GetUsersUserUrnFollowingsResponse
func (c *ClientWithResponses) GetUsersUserUrnFollowingsWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnFollowingsParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnFollowingsResponse, error) {
	rsp, err := c.GetUsersUserUrnFollowings(ctx, userUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserUrnFollowingsResponse(rsp)
}

// GetUsersUserUrnFollowingsFollowingUrnWithResponse request returning *GetUsersUserUrnFollowingsFollowingUrnResponse
func (c *ClientWithResponses) GetUsersUserUrnFollowingsFollowingUrnWithResponse(ctx context.Context, userUrn UserUrn, followingUrn FollowingUrn, reqEditors ...RequestEditorFn) (*GetUsersUserUrnFollowingsFollowingUrnResponse, error) {
	rsp, err := c.GetUsersUserUrnFollowingsFollowingUrn(ctx, userUrn, followingUrn, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserUrnFollowingsFollowingUrnResponse(rsp)
}

// GetUsersUserUrnLikesPlaylistsWithResponse request returning *GetUsersUserUrnLikesPlaylistsResponse
func (c *ClientWithResponses) GetUsersUserUrnLikesPlaylistsWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnLikesPlaylistsParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnLikesPlaylistsResponse, error) {
	rsp, err := c.GetUsersUserUrnLikesPlaylists(ctx, userUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserUrnLikesPlaylistsResponse(rsp)
}

// GetUsersUserUrnLikesTracksWithResponse request returning *GetUsersUserUrnLikesTracksResponse
func (c *ClientWithResponses) GetUsersUserUrnLikesTracksWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnLikesTracksParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnLikesTracksResponse, error) {
	rsp, err := c.GetUsersUserUrnLikesTracks(ctx, userUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserUrnLikesTracksResponse(rsp)
}

// GetUsersUserUrnPlaylistsWithResponse request returning *GetUsersUserUrnPlaylistsResponse
func (c *ClientWithResponses) GetUsersUserUrnPlaylistsWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnPlaylistsParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnPlaylistsResponse, error) {
	rsp, err := c.GetUsersUserUrnPlaylists(ctx, userUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserUrnPlaylistsResponse(rsp)
}

// GetUsersUserUrnTracksWithResponse request returning *GetUsersUserUrnTracksResponse
func (c *ClientWithResponses) GetUsersUserUrnTracksWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnTracksParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnTracksResponse, error) {
	rsp, err := c.GetUsersUserUrnTracks(ctx, userUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserUrnTracksResponse(rsp)
}

// GetUsersUserUrnWebProfilesWithResponse request returning *GetUsersUserUrnWebProfilesResponse
func (c *ClientWithResponses) GetUsersUserUrnWebProfilesWithResponse(ctx context.Context, userUrn UserUrn, params *GetUsersUserUrnWebProfilesParams, reqEditors ...RequestEditorFn) (*GetUsersUserUrnWebProfilesResponse, error) {
	rsp, err := c.GetUsersUserUrnWebProfiles(ctx, userUrn, params, reqEditors...)
	if err != nil {
		return nil, err
	}
	return ParseGetUsersUserUrnWebProfilesResponse(rsp)
}

// ParseGetConnectResponse parses an HTTP response from a GetConnectWithResponse call
func ParseGetConnectResponse(rsp *http.Response) (*GetConnectResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetConnectResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseDeleteLikesPlaylistsPlaylistUrnResponse parses an HTTP response from a DeleteLikesPlaylistsPlaylistUrnWithResponse call
func ParseDeleteLikesPlaylistsPlaylistUrnResponse(rsp *http.Response) (*DeleteLikesPlaylistsPlaylistUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLikesPlaylistsPlaylistUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostLikesPlaylistsPlaylistUrnResponse parses an HTTP response from a PostLikesPlaylistsPlaylistUrnWithResponse call
func ParsePostLikesPlaylistsPlaylistUrnResponse(rsp *http.Response) (*PostLikesPlaylistsPlaylistUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLikesPlaylistsPlaylistUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseDeleteLikesTracksTrackUrnResponse parses an HTTP response from a DeleteLikesTracksTrackUrnWithResponse call
func ParseDeleteLikesTracksTrackUrnResponse(rsp *http.Response) (*DeleteLikesTracksTrackUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteLikesTracksTrackUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostLikesTracksTrackUrnResponse parses an HTTP response from a PostLikesTracksTrackUrnWithResponse call
func ParsePostLikesTracksTrackUrnResponse(rsp *http.Response) (*PostLikesTracksTrackUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostLikesTracksTrackUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetMeResponse parses an HTTP response from a GetMeWithResponse call
func ParseGetMeResponse(rsp *http.Response) (*GetMeResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Me
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetMeActivitiesResponse parses an HTTP response from a GetMeActivitiesWithResponse call
func ParseGetMeActivitiesResponse(rsp *http.Response) (*GetMeActivitiesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeActivitiesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Activities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetMeActivitiesAllOwnResponse parses an HTTP response from a GetMeActivitiesAllOwnWithResponse call
func ParseGetMeActivitiesAllOwnResponse(rsp *http.Response) (*GetMeActivitiesAllOwnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeActivitiesAllOwnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Activities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetMeActivitiesTracksResponse parses an HTTP response from a GetMeActivitiesTracksWithResponse call
func ParseGetMeActivitiesTracksResponse(rsp *http.Response) (*GetMeActivitiesTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeActivitiesTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Activities
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetMeFollowersResponse parses an HTTP response from a GetMeFollowersWithResponse call
func ParseGetMeFollowersResponse(rsp *http.Response) (*GetMeFollowersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeFollowersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetMeFollowersFollowerUrnResponse parses an HTTP response from a GetMeFollowersFollowerUrnWithResponse call
func ParseGetMeFollowersFollowerUrnResponse(rsp *http.Response) (*GetMeFollowersFollowerUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeFollowersFollowerUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetMeFollowingsResponse parses an HTTP response from a GetMeFollowingsWithResponse call
func ParseGetMeFollowingsResponse(rsp *http.Response) (*GetMeFollowingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeFollowingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetMeFollowingsTracksResponse parses an HTTP response from a GetMeFollowingsTracksWithResponse call
func ParseGetMeFollowingsTracksResponse(rsp *http.Response) (*GetMeFollowingsTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeFollowingsTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest TracksList
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseDeleteMeFollowingsUserUrnResponse parses an HTTP response from a DeleteMeFollowingsUserUrnWithResponse call
func ParseDeleteMeFollowingsUserUrnResponse(rsp *http.Response) (*DeleteMeFollowingsUserUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteMeFollowingsUserUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseGetMeFollowingsUserUrnResponse parses an HTTP response from a GetMeFollowingsUserUrnWithResponse call
func ParseGetMeFollowingsUserUrnResponse(rsp *http.Response) (*GetMeFollowingsUserUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeFollowingsUserUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutMeFollowingsUserUrnResponse parses an HTTP response from a PutMeFollowingsUserUrnWithResponse call
func ParsePutMeFollowingsUserUrnResponse(rsp *http.Response) (*PutMeFollowingsUserUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutMeFollowingsUserUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMeLikesPlaylistsResponse parses an HTTP response from a GetMeLikesPlaylistsWithResponse call
func ParseGetMeLikesPlaylistsResponse(rsp *http.Response) (*GetMeLikesPlaylistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeLikesPlaylistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetMeLikesTracksResponse parses an HTTP response from a GetMeLikesTracksWithResponse call
func ParseGetMeLikesTracksResponse(rsp *http.Response) (*GetMeLikesTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeLikesTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetMePlaylistsResponse parses an HTTP response from a GetMePlaylistsWithResponse call
func ParseGetMePlaylistsResponse(rsp *http.Response) (*GetMePlaylistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMePlaylistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetMeTracksResponse parses an HTTP response from a GetMeTracksWithResponse call
func ParseGetMeTracksResponse(rsp *http.Response) (*GetMeTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetMeTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParsePostOauth2TokenResponse parses an HTTP response from a PostOauth2TokenWithResponse call
func ParsePostOauth2TokenResponse(rsp *http.Response) (*PostOauth2TokenResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostOauth2TokenResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON401 = &dest

	}

	return response, nil
}

// ParseGetPlaylistsResponse parses an HTTP response from a GetPlaylistsWithResponse call
func ParseGetPlaylistsResponse(rsp *http.Response) (*GetPlaylistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaylistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParsePostPlaylistsResponse parses an HTTP response from a PostPlaylistsWithResponse call
func ParsePostPlaylistsResponse(rsp *http.Response) (*PostPlaylistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostPlaylistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Playlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeletePlaylistsPlaylistUrnResponse parses an HTTP response from a DeletePlaylistsPlaylistUrnWithResponse call
func ParseDeletePlaylistsPlaylistUrnResponse(rsp *http.Response) (*DeletePlaylistsPlaylistUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeletePlaylistsPlaylistUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPlaylistsPlaylistUrnResponse parses an HTTP response from a GetPlaylistsPlaylistUrnWithResponse call
func ParseGetPlaylistsPlaylistUrnResponse(rsp *http.Response) (*GetPlaylistsPlaylistUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaylistsPlaylistUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Playlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParsePutPlaylistsPlaylistUrnResponse parses an HTTP response from a PutPlaylistsPlaylistUrnWithResponse call
func ParsePutPlaylistsPlaylistUrnResponse(rsp *http.Response) (*PutPlaylistsPlaylistUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutPlaylistsPlaylistUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Playlist
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPlaylistsPlaylistUrnRepostersResponse parses an HTTP response from a GetPlaylistsPlaylistUrnRepostersWithResponse call
func ParseGetPlaylistsPlaylistUrnRepostersResponse(rsp *http.Response) (*GetPlaylistsPlaylistUrnRepostersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaylistsPlaylistUrnRepostersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetPlaylistsPlaylistUrnTracksResponse parses an HTTP response from a GetPlaylistsPlaylistUrnTracksWithResponse call
func ParseGetPlaylistsPlaylistUrnTracksResponse(rsp *http.Response) (*GetPlaylistsPlaylistUrnTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetPlaylistsPlaylistUrnTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseDeleteRepostsPlaylistsPlaylistUrnResponse parses an HTTP response from a DeleteRepostsPlaylistsPlaylistUrnWithResponse call
func ParseDeleteRepostsPlaylistsPlaylistUrnResponse(rsp *http.Response) (*DeleteRepostsPlaylistsPlaylistUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepostsPlaylistsPlaylistUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostRepostsPlaylistsPlaylistUrnResponse parses an HTTP response from a PostRepostsPlaylistsPlaylistUrnWithResponse call
func ParsePostRepostsPlaylistsPlaylistUrnResponse(rsp *http.Response) (*PostRepostsPlaylistsPlaylistUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRepostsPlaylistsPlaylistUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseDeleteRepostsTracksTrackUrnResponse parses an HTTP response from a DeleteRepostsTracksTrackUrnWithResponse call
func ParseDeleteRepostsTracksTrackUrnResponse(rsp *http.Response) (*DeleteRepostsTracksTrackUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteRepostsTracksTrackUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostRepostsTracksTrackUrnResponse parses an HTTP response from a PostRepostsTracksTrackUrnWithResponse call
func ParsePostRepostsTracksTrackUrnResponse(rsp *http.Response) (*PostRepostsTracksTrackUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostRepostsTracksTrackUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetResolveResponse parses an HTTP response from a GetResolveWithResponse call
func ParseGetResolveResponse(rsp *http.Response) (*GetResolveResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetResolveResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 302:
		var dest Found
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8302 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostSignOutResponse parses an HTTP response from a PostSignOutWithResponse call
func ParsePostSignOutResponse(rsp *http.Response) (*PostSignOutResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostSignOutResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	return response, nil
}

// ParseGetTracksResponse parses an HTTP response from a GetTracksWithResponse call
func ParseGetTracksResponse(rsp *http.Response) (*GetTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParsePostTracksResponse parses an HTTP response from a PostTracksWithResponse call
func ParsePostTracksResponse(rsp *http.Response) (*PostTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Track
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	}

	return response, nil
}

// ParseDeleteTracksTrackUrnResponse parses an HTTP response from a DeleteTracksTrackUrnWithResponse call
func ParseDeleteTracksTrackUrnResponse(rsp *http.Response) (*DeleteTracksTrackUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &DeleteTracksTrackUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTracksTrackUrnResponse parses an HTTP response from a GetTracksTrackUrnWithResponse call
func ParseGetTracksTrackUrnResponse(rsp *http.Response) (*GetTracksTrackUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTracksTrackUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Track
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePutTracksTrackUrnResponse parses an HTTP response from a PutTracksTrackUrnWithResponse call
func ParsePutTracksTrackUrnResponse(rsp *http.Response) (*PutTracksTrackUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PutTracksTrackUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Track
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetTracksTrackUrnCommentsResponse parses an HTTP response from a GetTracksTrackUrnCommentsWithResponse call
func ParseGetTracksTrackUrnCommentsResponse(rsp *http.Response) (*GetTracksTrackUrnCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTracksTrackUrnCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Comments
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParsePostTracksTrackUrnCommentsResponse parses an HTTP response from a PostTracksTrackUrnCommentsWithResponse call
func ParsePostTracksTrackUrnCommentsResponse(rsp *http.Response) (*PostTracksTrackUrnCommentsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &PostTracksTrackUrnCommentsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 201:
		var dest Comment
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8201 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 422:
		var dest UnprocessableEntity
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON422 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 429:
		var dest TooManyRequests
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON429 = &dest

	}

	return response, nil
}

// ParseGetTracksTrackUrnFavoritersResponse parses an HTTP response from a GetTracksTrackUrnFavoritersWithResponse call
func ParseGetTracksTrackUrnFavoritersResponse(rsp *http.Response) (*GetTracksTrackUrnFavoritersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTracksTrackUrnFavoritersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTracksTrackUrnRelatedResponse parses an HTTP response from a GetTracksTrackUrnRelatedWithResponse call
func ParseGetTracksTrackUrnRelatedResponse(rsp *http.Response) (*GetTracksTrackUrnRelatedResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTracksTrackUrnRelatedResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTracksTrackUrnRepostersResponse parses an HTTP response from a GetTracksTrackUrnRepostersWithResponse call
func ParseGetTracksTrackUrnRepostersResponse(rsp *http.Response) (*GetTracksTrackUrnRepostersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTracksTrackUrnRepostersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetTracksTrackUrnStreamsResponse parses an HTTP response from a GetTracksTrackUrnStreamsWithResponse call
func ParseGetTracksTrackUrnStreamsResponse(rsp *http.Response) (*GetTracksTrackUrnStreamsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetTracksTrackUrnStreamsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Streams
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersResponse parses an HTTP response from a GetUsersWithResponse call
func ParseGetUsersResponse(rsp *http.Response) (*GetUsersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetUsersUserUrnResponse parses an HTTP response from a GetUsersUserUrnWithResponse call
func ParseGetUsersUserUrnResponse(rsp *http.Response) (*GetUsersUserUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersUserUrnFavoritesResponse parses an HTTP response from a GetUsersUserUrnFavoritesWithResponse call
func ParseGetUsersUserUrnFavoritesResponse(rsp *http.Response) (*GetUsersUserUrnFavoritesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserUrnFavoritesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetUsersUserUrnFollowersResponse parses an HTTP response from a GetUsersUserUrnFollowersWithResponse call
func ParseGetUsersUserUrnFollowersResponse(rsp *http.Response) (*GetUsersUserUrnFollowersResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserUrnFollowersResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetUsersUserUrnFollowingsResponse parses an HTTP response from a GetUsersUserUrnFollowingsWithResponse call
func ParseGetUsersUserUrnFollowingsResponse(rsp *http.Response) (*GetUsersUserUrnFollowingsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserUrnFollowingsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest Users
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetUsersUserUrnFollowingsFollowingUrnResponse parses an HTTP response from a GetUsersUserUrnFollowingsFollowingUrnWithResponse call
func ParseGetUsersUserUrnFollowingsFollowingUrnResponse(rsp *http.Response) (*GetUsersUserUrnFollowingsFollowingUrnResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserUrnFollowingsFollowingUrnResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest User
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersUserUrnLikesPlaylistsResponse parses an HTTP response from a GetUsersUserUrnLikesPlaylistsWithResponse call
func ParseGetUsersUserUrnLikesPlaylistsResponse(rsp *http.Response) (*GetUsersUserUrnLikesPlaylistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserUrnLikesPlaylistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersUserUrnLikesTracksResponse parses an HTTP response from a GetUsersUserUrnLikesTracksWithResponse call
func ParseGetUsersUserUrnLikesTracksResponse(rsp *http.Response) (*GetUsersUserUrnLikesTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserUrnLikesTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 400:
		var dest BadRequest
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8400 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 404:
		var dest NotFound
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.JSON404 = &dest

	}

	return response, nil
}

// ParseGetUsersUserUrnPlaylistsResponse parses an HTTP response from a GetUsersUserUrnPlaylistsWithResponse call
func ParseGetUsersUserUrnPlaylistsResponse(rsp *http.Response) (*GetUsersUserUrnPlaylistsResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserUrnPlaylistsResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetUsersUserUrnTracksResponse parses an HTTP response from a GetUsersUserUrnTracksWithResponse call
func ParseGetUsersUserUrnTracksResponse(rsp *http.Response) (*GetUsersUserUrnTracksResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserUrnTracksResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest struct {
			union json.RawMessage
		}
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}

// ParseGetUsersUserUrnWebProfilesResponse parses an HTTP response from a GetUsersUserUrnWebProfilesWithResponse call
func ParseGetUsersUserUrnWebProfilesResponse(rsp *http.Response) (*GetUsersUserUrnWebProfilesResponse, error) {
	bodyBytes, err := io.ReadAll(rsp.Body)
	defer func() { _ = rsp.Body.Close() }()
	if err != nil {
		return nil, err
	}

	response := &GetUsersUserUrnWebProfilesResponse{
		Body:         bodyBytes,
		HTTPResponse: rsp,
	}

	switch {
	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 200:
		var dest WebProfiles
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8200 = &dest

	case strings.Contains(rsp.Header.Get("Content-Type"), "json") && rsp.StatusCode == 401:
		var dest Unauthorized
		if err := json.Unmarshal(bodyBytes, &dest); err != nil {
			return nil, err
		}
		response.ApplicationjsonCharsetUtf8401 = &dest

	}

	return response, nil
}
